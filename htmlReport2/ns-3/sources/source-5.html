


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > AttributeParserEngine</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">io.telicent.jena.abac.attributes</a>
</div>

<h1>Coverage Summary for Class: AttributeParserEngine (io.telicent.jena.abac.attributes)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">AttributeParserEngine</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (16/16)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    81.1%
  </span>
  <span class="absValue">
    (73/90)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83.9%
  </span>
  <span class="absValue">
    (115/137)
  </span>
</td>
</tr>
  <tr>
    <td class="name">AttributeParserEngine$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (17/17)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    81.1%
  </span>
  <span class="absValue">
    (73/90)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    84.1%
  </span>
  <span class="absValue">
    (116/138)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; *  Copyright (c) Telicent Ltd.
&nbsp; *
&nbsp; *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; *  you may not use this file except in compliance with the License.
&nbsp; *  You may obtain a copy of the License at
&nbsp; *
&nbsp; *      http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; *  Unless required by applicable law or agreed to in writing, software
&nbsp; *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; *  See the License for the specific language governing permissions and
&nbsp; *  limitations under the License.
&nbsp; */
&nbsp;
&nbsp;package io.telicent.jena.abac.attributes;
&nbsp;
&nbsp;import static io.telicent.jena.abac.attributes.syntax.AEX.kwFALSE;
&nbsp;import static io.telicent.jena.abac.attributes.syntax.AEX.kwTRUE;
&nbsp;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.List;
&nbsp;import java.util.function.Function;
&nbsp;
&nbsp;import io.telicent.jena.abac.Hierarchy;
&nbsp;import io.telicent.jena.abac.attributes.syntax.*;
&nbsp;import io.telicent.jena.abac.attributes.syntax.tokens.Token;
&nbsp;import io.telicent.jena.abac.attributes.syntax.tokens.TokenType;
&nbsp;import io.telicent.jena.abac.attributes.syntax.tokens.Tokenizer;
&nbsp;import io.telicent.jena.abac.attributes.syntax.tokens.TokenizerABAC;
&nbsp;
&nbsp;class AttributeParserEngine {
&nbsp;
&nbsp;    // Expr = ExprOr | &quot;*&quot; | &quot;!&quot;
&nbsp;    // ExprOr = ExprAnd (| ExprOr)*
&nbsp;    // ExprAnd = ExprRel (&amp; ExprAnd) *
&nbsp;    // ExprRel = Bracketted | Attr (RE ValueTerm)?
&nbsp;    // Attr = [a-zA-Z_](([a-zA-Z0-9_:.-+])*[a-zA-Z_0-9])?
&nbsp;    // ValueTerm = attr or signed number
&nbsp;    // RE = &quot;=&quot;, &quot;&lt;&quot;, &quot;&gt;&quot;, &quot;!=&quot;
&nbsp;
&nbsp;    // Attr &#39;=&#39; ValueTerm
&nbsp;
&nbsp;
&nbsp;    private final Tokenizer tokenizer;
&nbsp;
&nbsp;    AttributeParserEngine(String string) {
<b class="fc">&nbsp;        this(TokenizerABAC.create().fromString(string).build());</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    AttributeParserEngine(Tokenizer tokenizer) {</b>
<b class="fc">&nbsp;        this.tokenizer = tokenizer;</b>
&nbsp;    }
&nbsp;
&nbsp;    Tokenizer tokenizer() {
<b class="fc">&nbsp;        return tokenizer;</b>
&nbsp;    }
&nbsp;
&nbsp;    boolean endOfTokens() {
<b class="fc">&nbsp;        return ! tokenizer.hasNext();</b>
&nbsp;    }
&nbsp;
&nbsp;    AttributeExpr attributeExpression( ) {
<b class="fc">&nbsp;        AttributeExpr expr = readExprOr();</b>
<b class="fc">&nbsp;        return expr;</b>
&nbsp;    }
&nbsp;
&nbsp;    // Used in lists, not labels.
&nbsp;    AttributeValue attributeValue( ) {
&nbsp;        // Like readExprRel except only allowing &quot;=&quot;
<b class="pc">&nbsp;        if ( tokenizer.eof() )</b>
<b class="nc">&nbsp;            throw new AttributeSyntaxError(&quot;END&quot;);</b>
<b class="fc">&nbsp;        AE_Attribute attr = readAttribute();</b>
<b class="fc">&nbsp;        Attribute attribute = attr.attribute();</b>
&nbsp;
<b class="fc">&nbsp;        if ( tokenizer.eof() )</b>
&nbsp;            // Plain attribute
<b class="fc">&nbsp;            return AttributeValue.of(attribute, AttributeValue.dftTrue);</b>
<b class="fc">&nbsp;        Token relToken = tokenizer.peek();</b>
<b class="fc">&nbsp;        if ( relToken.getType() != TokenType.EQ )</b>
&nbsp;            // Plain attribute
<b class="fc">&nbsp;            return AttributeValue.of(attribute, AttributeValue.dftTrue);</b>
&nbsp;
&nbsp;        // It&#39;s &quot;=&quot; EQ
<b class="fc">&nbsp;        /*Token relToken = */tokenizer.next();</b>
<b class="fc">&nbsp;        if ( tokenizer.eof() )</b>
<b class="fc">&nbsp;            throw new AttributeSyntaxError(&quot;Expected value after `=`&quot;);</b>
&nbsp;
<b class="fc">&nbsp;        AE_AttrValue expr2 = readAttributeValue();</b>
<b class="fc">&nbsp;        ValueTerm value = expr2.asValue();</b>
<b class="fc">&nbsp;        return AttributeValue.of(attribute, value);</b>
&nbsp;    }
&nbsp;
&nbsp;    // Hierarchy = Attribute &#39;:&#39; ( ValueTerm (&#39;,&#39; ValueTerm)* )?
&nbsp;
&nbsp;    Hierarchy hierarchy() {
<b class="pc">&nbsp;        if ( tokenizer.eof() )</b>
<b class="nc">&nbsp;            throw new AttributeSyntaxError(&quot;END&quot;);</b>
<b class="fc">&nbsp;        AE_Attribute attr = readAttribute();</b>
<b class="fc">&nbsp;        Attribute attribute = attr.attribute();</b>
<b class="fc">&nbsp;        if ( tokenizer.eof() )</b>
<b class="fc">&nbsp;            throw new AttributeSyntaxError(&quot;Unexpected end to attribute value hierarchy&quot;);</b>
&nbsp;
<b class="fc">&nbsp;        Token token = tokenizer.next();</b>
<b class="pc">&nbsp;        if ( ! token.hasType(TokenType.COLON) )</b>
<b class="nc">&nbsp;            throw new AttributeSyntaxError(&quot;Expected &#39;:&#39; after attribute name in hierarchy: &quot;+token);</b>
&nbsp;//            if ( tokenizer.eof() )
&nbsp;//                throw new AttributeSyntaxError(&quot;Unexpected end to attribute hierarchy&quot;);
<b class="fc">&nbsp;        List&lt;ValueTerm&gt; values = parseListValues();</b>
<b class="fc">&nbsp;        return new Hierarchy(attribute, values);</b>
&nbsp;    }
&nbsp;
&nbsp;    List&lt;ValueTerm&gt; parseListValues() {
<b class="fc">&nbsp;        Function&lt;AttributeParserEngine, ValueTerm&gt; parseOneItem = (parser) -&gt; parser.readAttributeValue().asValue();</b>
<b class="fc">&nbsp;        List&lt;ValueTerm&gt; values = parseList(parseOneItem);</b>
<b class="fc">&nbsp;        return values;</b>
&nbsp;    }
&nbsp;
&nbsp;    private AttributeExpr readExprOr() {
<b class="pc">&nbsp;        if ( tokenizer.eof() )</b>
<b class="nc">&nbsp;            throw new AttributeSyntaxError(&quot;END&quot;);</b>
<b class="fc">&nbsp;        AttributeExpr expr1 = readExprAnd();</b>
&nbsp;        for(;;) {
<b class="fc">&nbsp;            if ( tokenizer.eof() )</b>
<b class="fc">&nbsp;                return expr1;</b>
<b class="fc">&nbsp;            Token token = tokenizer.peek();</b>
&nbsp;            // &quot;|&quot; or &quot;||&quot;
<b class="fc">&nbsp;            if ( token.getType() == TokenType.VBAR || token.getType() == TokenType.LOGICAL_OR ) {</b>
<b class="fc">&nbsp;                tokenizer.next();</b>
<b class="fc">&nbsp;                AttributeExpr expr2 = readExprAnd();</b>
<b class="fc">&nbsp;                expr1 = new AE_Or(expr1, expr2);</b>
&nbsp;                continue;
&nbsp;            }
<b class="fc">&nbsp;            return expr1;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private AttributeExpr readExprAnd() {
<b class="pc">&nbsp;        if ( tokenizer.eof() )</b>
<b class="nc">&nbsp;            throw new AttributeSyntaxError(&quot;END&quot;);</b>
<b class="fc">&nbsp;        AttributeExpr expr1 = readExprUnary();</b>
&nbsp;        for(;;) {
<b class="fc">&nbsp;            if ( tokenizer.eof() )</b>
<b class="fc">&nbsp;                return expr1;</b>
<b class="fc">&nbsp;            Token token = tokenizer.peek();</b>
&nbsp;            // &quot;&amp;&quot; or &quot;&amp;&amp;&quot;
<b class="fc">&nbsp;            if ( token.getType() == TokenType.AMPERSAND || token.getType() == TokenType.LOGICAL_AND  ) {</b>
<b class="fc">&nbsp;                Token t2 = tokenizer.next();</b>
<b class="fc">&nbsp;                AttributeExpr expr2 = readExprUnary();</b>
<b class="fc">&nbsp;                expr1 = new AE_And(expr1, expr2);</b>
&nbsp;                continue;
&nbsp;            }
<b class="fc">&nbsp;            return expr1;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private AttributeExpr readExprUnary() {
<b class="fc">&nbsp;        TokenType peek = tokenizer.peek().getType();</b>
&nbsp;
<b class="fc">&nbsp;        if ( peek == TokenType.WORD || peek == TokenType.STRING )</b>
<b class="fc">&nbsp;            return readExprRel();</b>
&nbsp;
<b class="fc">&nbsp;        if ( peek == TokenType.LPAREN ) {</b>
<b class="fc">&nbsp;            Token t = tokenizer.next();</b>
<b class="fc">&nbsp;            AttributeExpr expr = attributeExpression();</b>
<b class="pc">&nbsp;            if ( tokenizer.eof() )</b>
<b class="nc">&nbsp;                throw new AttributeSyntaxError(&quot;No RPAREN: &quot;+t);</b>
<b class="fc">&nbsp;            Token token = tokenizer.next();</b>
<b class="pc">&nbsp;            if ( token.getType() == TokenType.RPAREN )</b>
<b class="fc">&nbsp;                return new AE_Bracketted(expr);</b>
<b class="nc">&nbsp;            throw new AttributeSyntaxError(&quot;Expected RPAREN: &quot;+token);</b>
&nbsp;        }
&nbsp;
<b class="pc">&nbsp;        if ( peek == TokenType.LBRACE ) {</b>
<b class="nc">&nbsp;            Token t1 = tokenizer.next();</b>
<b class="nc">&nbsp;            if ( tokenizer.eof() )</b>
<b class="nc">&nbsp;                throw new AttributeSyntaxError(&quot;No RBRACE: &quot;+t1);</b>
<b class="nc">&nbsp;            Token token = tokenizer.next();</b>
<b class="nc">&nbsp;            if ( token.getType() != TokenType.WORD )</b>
<b class="nc">&nbsp;                throw new AttributeSyntaxError(&quot;Expected WORD after: &quot;+t1);</b>
<b class="nc">&nbsp;            String varName = token.getImage();</b>
<b class="nc">&nbsp;            Token t2 = tokenizer.next();</b>
<b class="nc">&nbsp;            if ( t2.getType() == TokenType.RBRACE )</b>
<b class="nc">&nbsp;                return new AE_Var(varName);</b>
<b class="nc">&nbsp;            throw new AttributeSyntaxError(&quot;Expected RBRACE: &quot;+t2);</b>
&nbsp;        }
<b class="fc">&nbsp;        throw new AttributeSyntaxError(&quot;Not recognized: &quot;+tokenizer.peek());</b>
&nbsp;    }
&nbsp;
&nbsp;    private AttributeExpr readExprRel() {
<b class="pc">&nbsp;        if ( tokenizer.eof() )</b>
<b class="nc">&nbsp;            throw new AttributeSyntaxError(&quot;END&quot;);</b>
<b class="fc">&nbsp;        AE_Attribute expr1 = readAttribute();</b>
&nbsp;        // MaybeOneOf to follow.
<b class="fc">&nbsp;        if ( tokenizer.eof() )</b>
<b class="fc">&nbsp;            return expr1;</b>
<b class="fc">&nbsp;        Token relToken = tokenizer.peek();</b>
&nbsp;
&nbsp;        // Is it a relationship token?
<b class="fc">&nbsp;        switch ( relToken.getType() ) {</b>
&nbsp;            // OK
&nbsp;            case LT, LE, GT, GE, EQ, NE:
&nbsp;                break;
&nbsp;            // Plain term variable
<b class="fc">&nbsp;            default: return expr1;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        /*Token relToken = */tokenizer.next();</b>
<b class="fc">&nbsp;        if ( tokenizer.eof() )</b>
<b class="fc">&nbsp;            throw new AttributeSyntaxError(&quot;Expected a relationship operator: &#39;&lt;&#39;, &#39;=&#39;, &#39;&gt;&#39;, &#39;&lt;=&#39;, &#39;&gt;=&#39;&quot;);</b>
&nbsp;
<b class="fc">&nbsp;        AE_AttrValue expr2 = readAttributeValue();</b>
&nbsp;
<b class="pc">&nbsp;        Operator op = switch ( relToken.getType() ) {</b>
<b class="fc">&nbsp;            case EQ -&gt;  Operator.EQ;</b>
&nbsp;            //case EQUIVALENT -&gt;  Operator.EQ;
<b class="fc">&nbsp;            case LT -&gt; Operator.LT;</b>
<b class="fc">&nbsp;            case LE -&gt;  Operator.LE;</b>
<b class="fc">&nbsp;            case GT -&gt;  Operator.GT;</b>
<b class="fc">&nbsp;            case GE -&gt; Operator.GE;</b>
<b class="fc">&nbsp;            case NE -&gt; Operator.NE;</b>
&nbsp;            // Not OK.
<b class="nc">&nbsp;            default -&gt; throw new AttributeSyntaxError(&quot;Not a relationship operator: &#39;&quot;+relToken+&quot;&#39;&quot;);</b>
&nbsp;        };
<b class="fc">&nbsp;        return new AE_RelAny(relToken.getImage(), op, expr1, expr2);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An attribute is a word starting with a letter, or a quoted string.
&nbsp;     */
&nbsp;    private AE_Attribute readAttribute() {
<b class="fc">&nbsp;        Token peek = tokenizer.peek();</b>
<b class="fc">&nbsp;        TokenType peekType = peek.getType();</b>
&nbsp;
<b class="pc">&nbsp;        if ( peek.isNumber() )</b>
<b class="nc">&nbsp;            throw new AttributeSyntaxError(&quot;Expected an attribute: Got a number: &quot;+peek);</b>
&nbsp;
<b class="fc">&nbsp;        if ( peek.isWord() || peek.isString() ) {</b>
<b class="fc">&nbsp;            Token t = tokenizer.next();</b>
<b class="fc">&nbsp;            String str = t.getImage();</b>
<b class="fc">&nbsp;            switch(str) {</b>
&nbsp;                case kwTRUE, kwFALSE:
<b class="fc">&nbsp;                    throw new AttributeSyntaxError(&quot;Found keyword &#39;&quot;+str+&quot;&#39;, not an attribute&quot;);</b>
&nbsp;            }
<b class="fc">&nbsp;            return AE_Attribute.create(str);</b>
&nbsp;        }
<b class="fc">&nbsp;        throw new AttributeSyntaxError(&quot;Expected an attribute: Not recognized: &quot;+peek);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An attribute value is a word (starts with a letter) or string, same as an attribute,
&nbsp;     * or a number. It can be a keyword.
&nbsp;     */
&nbsp;    private AE_AttrValue readAttributeValue() {
<b class="fc">&nbsp;        Token peek = tokenizer.peek();</b>
<b class="fc">&nbsp;        TokenType peekType = peek.getType();</b>
<b class="pc">&nbsp;        if ( peek.isWord() || peek.isString() || peek.isNumber() ) {</b>
<b class="fc">&nbsp;            Token t = tokenizer.next();</b>
<b class="fc">&nbsp;            String str = t.getImage();</b>
<b class="fc">&nbsp;            return AE_AttrValue.create(str);</b>
&nbsp;        }
<b class="nc">&nbsp;        throw new AttributeSyntaxError(&quot;Expected an attribute value: Not recognized: &quot;+peek);</b>
&nbsp;    }
&nbsp;
&nbsp;    &lt;X&gt; List&lt;X&gt; parseList(Function&lt;AttributeParserEngine, X&gt; parseOneItem) {
<b class="fc">&nbsp;        return parseList(parseOneItem, TokenType.COMMA);</b>
&nbsp;    }
&nbsp;
&nbsp;    &lt;X&gt; List&lt;X&gt; parseList(Function&lt;AttributeParserEngine, X&gt; parseOneItem, TokenType separator) {
<b class="fc">&nbsp;        if ( endOfTokens() )</b>
&nbsp;            // Empty.
<b class="fc">&nbsp;            return List.of();</b>
&nbsp;
<b class="fc">&nbsp;        List&lt;X&gt; acc = new ArrayList&lt;&gt;();</b>
&nbsp;        for(;;) {
<b class="fc">&nbsp;            X e = parseOneItem.apply(this);</b>
<b class="fc">&nbsp;            acc.add(e);</b>
&nbsp;            // More?
<b class="fc">&nbsp;            Token t2 = tokenizer.peek();</b>
<b class="fc">&nbsp;            if ( t2 == null )</b>
&nbsp;                break;
<b class="fc">&nbsp;            if ( t2.getType() != separator )</b>
&nbsp;                break;
&nbsp;            // Read separator
<b class="fc">&nbsp;            tokenizer.next();</b>
<b class="fc">&nbsp;            if ( ! tokenizer.hasNext() ) {</b>
&nbsp;                // It was a trailing separator.
<b class="fc">&nbsp;                throw new AttributeSyntaxError(&quot;Trailing comma&quot;);</b>
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;        if ( ! tokenizer.eof() )</b>
<b class="fc">&nbsp;            throw new AttributeSyntaxError(&quot;Trailing content: &quot;+tokenizer.peek()+&quot; ...&quot;);</b>
<b class="fc">&nbsp;        return acc;</b>
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-11-26 11:51</div>
</div>
</body>
</html>
