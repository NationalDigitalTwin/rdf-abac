


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > StoreFmt</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">io.telicent.jena.abac.labels</a>
</div>

<h1>Coverage Summary for Class: StoreFmt (io.telicent.jena.abac.labels)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">StoreFmt</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    79.2%
  </span>
  <span class="absValue">
    (38/48)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    93.4%
  </span>
  <span class="absValue">
    (57/61)
  </span>
</td>
</tr>
  <tr>
    <td class="name">StoreFmt$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">StoreFmt$Encoder</td>
  </tr>
  <tr>
    <td class="name">StoreFmt$IntBytes</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">StoreFmt$NodeType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">StoreFmt$Parser</td>
  </tr>
  <tr>
    <td class="name">StoreFmt$Writer</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (3/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    37.5%
  </span>
  <span class="absValue">
    (3/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (11/22)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    85.7%
  </span>
  <span class="absValue">
    (18/21)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75.8%
  </span>
  <span class="absValue">
    (47/62)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    84.2%
  </span>
  <span class="absValue">
    (80/95)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package io.telicent.jena.abac.labels;
&nbsp;
&nbsp;import org.apache.jena.graph.Node;
&nbsp;
&nbsp;import java.io.IOException;
&nbsp;import java.nio.ByteBuffer;
&nbsp;import java.nio.ByteOrder;
&nbsp;import java.nio.CharBuffer;
&nbsp;import java.nio.charset.CharsetDecoder;
&nbsp;import java.nio.charset.CharsetEncoder;
&nbsp;import java.nio.charset.StandardCharsets;
&nbsp;import java.util.Collection;
&nbsp;import java.util.List;
&nbsp;
&nbsp;/**
&nbsp; * The storage format interface for {@code RocksDB}-based label stores.
&nbsp; * There are storage format implementations for string-based and id-based encoding of nodes into buffers,
&nbsp; * which are passed to RocksDB for storage.
&nbsp; * &lt;p&gt;
&nbsp; * This class also provides a number of static utility methods for parts of the encoding and decoding
&nbsp; * process which do not vary by (string-based versus id-based) storage formats.
&nbsp; */
<b class="pc">&nbsp;public interface StoreFmt {</b>
&nbsp;
&nbsp;    /**
&nbsp;     * The ordering of {@code NodeType} enum values was initially defined for {@code Any} to be last in order to respect
&nbsp;     * how wildcards are processed in seeking {@link LabelsStoreRocksDB}.
&nbsp;     * As the ordinal values will be encoded on storage, these MUST NOT BE CHANGED.
&nbsp;     */
<b class="fc">&nbsp;    enum NodeType {</b>
<b class="fc">&nbsp;        URI, Literal, Blank, Any;</b>
&nbsp;
&nbsp;        static NodeType of(Node node) {
<b class="fc">&nbsp;            if (node.isURI()) {</b>
<b class="fc">&nbsp;                return NodeType.URI;</b>
<b class="fc">&nbsp;            } else if (node.isLiteral()) {</b>
<b class="fc">&nbsp;                return NodeType.Literal;</b>
<b class="fc">&nbsp;            } else if (node.isBlank()) {</b>
<b class="fc">&nbsp;                return NodeType.Blank;</b>
&nbsp;            } else {
<b class="fc">&nbsp;                return NodeType.Any;</b>
&nbsp;            }
&nbsp;        }
&nbsp;    };
&nbsp;
&nbsp;    /**
&nbsp;     * Create an encoder that uses this storage format
&nbsp;     * @return a new encoder
&nbsp;     */
&nbsp;    public Encoder createEncoder();
&nbsp;
&nbsp;    /**
&nbsp;     * Create a parser that uses this storage format
&nbsp;     * @return a new parser
&nbsp;     */
&nbsp;    public Parser createParser();
&nbsp;
&nbsp;    /**
&nbsp;     * The object that transforms triples, nodes and values into sequences of bytes for storage in {@code RocksDB}
&nbsp;     */
&nbsp;    public interface Encoder {
&nbsp;
&nbsp;        Encoder formatSingleNode(final ByteBuffer byteBuffer, final Node node);
&nbsp;
&nbsp;        Encoder formatStrings(final ByteBuffer byteBuffer, final List&lt;String&gt; strings);
&nbsp;
&nbsp;        Encoder formatTriple(final ByteBuffer byteBuffer, final Node subject, final Node predicate, final Node object);
&nbsp;
&nbsp;    };
&nbsp;
&nbsp;    /**
&nbsp;     * The object that reads sequences of bytes from storage in {@code RocksDB} back into triples, nodes and values.
&nbsp;     */
&nbsp;    public interface Parser {
&nbsp;
&nbsp;        Node parseSingleNode(final ByteBuffer byteBuffer);
&nbsp;
&nbsp;        Parser parseTriple(final ByteBuffer byteBuffer, final List&lt;Node&gt; spo);
&nbsp;
&nbsp;        Parser parseStrings(final ByteBuffer valueBuffer, final Collection&lt;String&gt; labels);
&nbsp;    };
&nbsp;
&nbsp;    static void encodeNode(Writer writer, Node node) {
&nbsp;
&nbsp;        try {
<b class="pc">&nbsp;            switch (NodeType.of(node)) {</b>
&nbsp;                case Any:
&nbsp;                    break;
&nbsp;                case URI:
<b class="fc">&nbsp;                    writer.write(node.getURI());</b>
&nbsp;                    break;
&nbsp;                case Literal:
<b class="fc">&nbsp;                    writer.write(node.getLiteral().getLexicalForm());</b>
&nbsp;                    break;
&nbsp;                case Blank:
<b class="fc">&nbsp;                    writer.write(node.getBlankNodeLabel());</b>
&nbsp;                    break;
&nbsp;            };
<b class="nc">&nbsp;        } catch (IOException e) {</b>
<b class="nc">&nbsp;            throw new RuntimeException(&quot;Exception when formatting/writing node&quot;, e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Encode an integer in the standard number of bytes for an integer (4)
&nbsp;     * @param byteBuffer
&nbsp;     * @param i the integer
&nbsp;     */
&nbsp;    static void encodeInt(ByteBuffer byteBuffer, int i) {
&nbsp;
<b class="pc">&nbsp;        assert byteBuffer.order() == ByteOrder.LITTLE_ENDIAN;</b>
<b class="fc">&nbsp;        byteBuffer.putInt(i);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Format a number of strings,
&nbsp;     * preceded by a count of the strings, then an array of the sizes of the strings
&nbsp;     *
&nbsp;     * @param byteBuffer target of the encoding
&nbsp;     * @param strings to encode
&nbsp;     */
&nbsp;    static void formatStrings(final ByteBuffer byteBuffer, final List&lt;String&gt; strings) {
<b class="fc">&nbsp;        var count = strings.size();</b>
<b class="fc">&nbsp;        StoreFmt.encodeInt(byteBuffer, count);</b>
<b class="fc">&nbsp;        int[] encodedSizes = new int[count];</b>
<b class="fc">&nbsp;        var nextIndex = 0;</b>
<b class="fc">&nbsp;        var sizesPosition =  byteBuffer.position();</b>
&nbsp;        // Allow space for the string lengths
<b class="fc">&nbsp;        var nextPosition = sizesPosition + 4 * count;</b>
<b class="fc">&nbsp;        byteBuffer.position(nextPosition);</b>
&nbsp;
<b class="fc">&nbsp;        var charsetEncoder = StandardCharsets.UTF_8.newEncoder();</b>
<b class="fc">&nbsp;        for (String string : strings) {</b>
<b class="fc">&nbsp;            var result = charsetEncoder.encode(CharBuffer.wrap(string), byteBuffer, true);</b>
<b class="pc">&nbsp;            if (!result.isUnderflow()) {</b>
<b class="nc">&nbsp;                throw new RuntimeException(</b>
<b class="nc">&nbsp;                    new IOException(&quot;Implementation error - format strings - LabelsRocksFormatter&#39;s ByteBuffer should be larger than current limit &quot; + byteBuffer.capacity()));</b>
&nbsp;            }
<b class="fc">&nbsp;            encodedSizes[nextIndex++] = byteBuffer.position() - nextPosition;</b>
<b class="fc">&nbsp;            nextPosition = byteBuffer.position();</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        byteBuffer.position(sizesPosition);</b>
<b class="fc">&nbsp;        for (int encodedSize : encodedSizes) {</b>
<b class="fc">&nbsp;            StoreFmt.encodeInt(byteBuffer, encodedSize);</b>
&nbsp;        }
<b class="fc">&nbsp;        byteBuffer.position(nextPosition);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Parse a single string of known number of bytes encoded in a bytebuffer
&nbsp;     * @param byteBuffer containing the encoded string
&nbsp;     * @param decoder the decoder to use
&nbsp;     * @param len the number of bytes to decode
&nbsp;     * @return String
&nbsp;     */
&nbsp;    static String parseString(final ByteBuffer byteBuffer, final CharsetDecoder decoder, final int len) {
<b class="fc">&nbsp;        var pos = byteBuffer.position();</b>
<b class="fc">&nbsp;        var slice = byteBuffer.slice(pos, len);</b>
<b class="fc">&nbsp;        var chars = CharBuffer.allocate(len);</b>
<b class="fc">&nbsp;        decoder.decode(slice, chars, true);</b>
<b class="fc">&nbsp;        byteBuffer.position(pos + len);</b>
<b class="fc">&nbsp;        return chars.flip().toString();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Parse back a number of strings encoded as (count,lengths[],strings)
&nbsp;     *
&nbsp;     * @param byteBuffer containing the encoded strings
&nbsp;     * @param decoder to use to decode to characters
&nbsp;     * @param strings result list to add decoded strings to
&nbsp;     */
&nbsp;    static void parseStrings(final ByteBuffer byteBuffer, final CharsetDecoder decoder, final Collection&lt;String&gt; strings) {
<b class="fc">&nbsp;        var count = StoreFmt.decodeInt(byteBuffer);</b>
<b class="fc">&nbsp;        int[] encodedSizes = new int[count];</b>
<b class="fc">&nbsp;        for (int i = 0; i &lt; count; i++) {</b>
<b class="fc">&nbsp;            encodedSizes[i] = StoreFmt.decodeInt(byteBuffer);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        for (int i = 0; i &lt; count; i++) {</b>
<b class="fc">&nbsp;            int len = encodedSizes[i];</b>
<b class="fc">&nbsp;            strings.add(StoreFmt.parseString(byteBuffer, decoder, len));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Decode a single 4-byte integer encoded little endianly
&nbsp;     *
&nbsp;     * @param byteBuffer containing the encoded integer
&nbsp;     * @return the integer value retrieved from the bytebuffer
&nbsp;     */
&nbsp;    static int decodeInt(ByteBuffer byteBuffer) {
<b class="pc">&nbsp;        assert byteBuffer.order() == ByteOrder.LITTLE_ENDIAN;</b>
<b class="fc">&nbsp;        return byteBuffer.getInt();</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    enum IntBytes {</b>
<b class="fc">&nbsp;        OneByte, TwoBytes, FourBytes, EightBytes;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Format a long value flexibly according to how big it is,
&nbsp;     * as how big it is will be recorded elsewhere (in another part of the encoding, or implicitly).
&nbsp;     *
&nbsp;     * @param byteBuffer to format into
&nbsp;     * @param value the long to format
&nbsp;     * @return how much space the long value takes up.
&nbsp;     */
&nbsp;    static IntBytes formatLongVariable(final ByteBuffer byteBuffer, long value) {
&nbsp;
<b class="pc">&nbsp;        assert byteBuffer.order() == ByteOrder.LITTLE_ENDIAN;</b>
<b class="fc">&nbsp;        if (value &gt; Integer.MAX_VALUE || value &lt; Integer.MIN_VALUE) {</b>
<b class="fc">&nbsp;            byteBuffer.putLong(value);</b>
<b class="fc">&nbsp;            return IntBytes.EightBytes;</b>
<b class="fc">&nbsp;        } else if (value &gt; Short.MAX_VALUE || value &lt; Short.MIN_VALUE) {</b>
<b class="fc">&nbsp;            byteBuffer.putInt((int)value);</b>
<b class="fc">&nbsp;            return IntBytes.FourBytes;</b>
<b class="fc">&nbsp;        } else if (value &gt; Byte.MAX_VALUE || value &lt; Byte.MIN_VALUE) {</b>
<b class="fc">&nbsp;            byteBuffer.putShort((short) value);</b>
<b class="fc">&nbsp;            return IntBytes.TwoBytes;</b>
&nbsp;        } else {
<b class="fc">&nbsp;            byteBuffer.put((byte) value);</b>
<b class="fc">&nbsp;            return IntBytes.OneByte;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * parse back into a long, which may have been encoded a byte, short, int or long
&nbsp;     * @param byteBuffer contains the encoded long
&nbsp;     * @param size tells us what the encoding was
&nbsp;     * @return the decoding of the encoded long
&nbsp;     */
&nbsp;    static long parseLongVariable(final ByteBuffer byteBuffer, IntBytes size) {
&nbsp;
<b class="pc">&nbsp;        assert byteBuffer.order() == ByteOrder.LITTLE_ENDIAN;</b>
<b class="pc">&nbsp;        return switch (size) {</b>
<b class="fc">&nbsp;            case OneByte -&gt; byteBuffer.get();</b>
<b class="fc">&nbsp;            case TwoBytes -&gt; byteBuffer.getShort();</b>
<b class="fc">&nbsp;            case FourBytes -&gt; byteBuffer.getInt();</b>
<b class="fc">&nbsp;            case EightBytes -&gt; byteBuffer.getLong();</b>
&nbsp;        };
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An implementation of {@link java.io.Writer} which writes to a {@link ByteBuffer}
&nbsp;     */
&nbsp;    class Writer extends java.io.Writer {
&nbsp;
<b class="fc">&nbsp;        Writer(final ByteBuffer byteBuffer, final CharsetEncoder charsetEncoder) {</b>
<b class="fc">&nbsp;            this.byteBuffer = byteBuffer;</b>
<b class="fc">&nbsp;            this.charsetEncoder = charsetEncoder;</b>
&nbsp;        }
&nbsp;
&nbsp;        private final ByteBuffer byteBuffer;
&nbsp;        private final CharsetEncoder charsetEncoder;
&nbsp;
&nbsp;        @Override
&nbsp;        public void write(char[] cbuf, int off, int len) throws IOException {
<b class="nc">&nbsp;            var charBuffer = CharBuffer.wrap(cbuf, off, len);</b>
&nbsp;            while (true) {
<b class="nc">&nbsp;                var pos = byteBuffer.position();</b>
<b class="nc">&nbsp;                var result = charsetEncoder.encode(charBuffer, byteBuffer, true);</b>
<b class="nc">&nbsp;                if (result.isOverflow()) {</b>
&nbsp;                    // ignore the partial, overflowed encoding, try again in a bigger buffer
<b class="nc">&nbsp;                    byteBuffer.position(pos);</b>
<b class="nc">&nbsp;                    extendByteBuffer();</b>
&nbsp;                    continue;
&nbsp;                }
<b class="nc">&nbsp;                if (!result.isUnderflow()) {</b>
<b class="nc">&nbsp;                    throw new IOException(&quot;Implementation error - format labels/triples - LabelsRocksFormatter&#39;s ByteBuffer should be larger than current limit &quot; + byteBuffer.capacity());</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void write(String s) throws IOException {
<b class="fc">&nbsp;            var charBuffer = CharBuffer.wrap(s);</b>
&nbsp;            while (true) {
<b class="fc">&nbsp;                var pos = byteBuffer.position();</b>
<b class="fc">&nbsp;                var result = charsetEncoder.encode(charBuffer, byteBuffer, true);</b>
<b class="fc">&nbsp;                if (result.isOverflow()) {</b>
&nbsp;                    // ignore the partial, overflowed encoding, try again in a bigger buffer
<b class="fc">&nbsp;                    byteBuffer.position(pos);</b>
<b class="fc">&nbsp;                    extendByteBuffer();</b>
&nbsp;                    continue;
&nbsp;                }
<b class="pc">&nbsp;                if (!result.isUnderflow()) {</b>
<b class="nc">&nbsp;                    throw new IOException(&quot;Implementation error - format labels/triples - LabelsRocksFormatter&#39;s ByteBuffer should be larger than current limit &quot; + byteBuffer.capacity());</b>
&nbsp;                }
&nbsp;                break;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        private void extendByteBuffer() {
<b class="fc">&nbsp;            throw new RuntimeException(&quot;extendByteBuffer() not implemented&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void flush() {
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        @Override
&nbsp;        public void close() {
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-11-26 11:51</div>
</div>
</body>
</html>
