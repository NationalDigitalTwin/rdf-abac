


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > TokenizerABAC</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">io.telicent.jena.abac.attributes.syntax.tokens</a>
</div>

<h1>Coverage Summary for Class: TokenizerABAC (io.telicent.jena.abac.attributes.syntax.tokens)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">TokenizerABAC</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    74.4%
  </span>
  <span class="absValue">
    (29/39)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    43.1%
  </span>
  <span class="absValue">
    (121/281)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    59.8%
  </span>
  <span class="absValue">
    (220/368)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; *  Copyright (c) Telicent Ltd.
&nbsp; *
&nbsp; *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; *  you may not use this file except in compliance with the License.
&nbsp; *  You may obtain a copy of the License at
&nbsp; *
&nbsp; *      http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; *  Unless required by applicable law or agreed to in writing, software
&nbsp; *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; *  See the License for the specific language governing permissions and
&nbsp; *  limitations under the License.
&nbsp; */
&nbsp;
&nbsp;package io.telicent.jena.abac.attributes.syntax.tokens;
&nbsp;
&nbsp;import static org.apache.jena.atlas.lib.Chars.*;
&nbsp;import static org.apache.jena.riot.system.RiotChars.*;
&nbsp;
&nbsp;import java.util.NoSuchElementException;
&nbsp;import java.util.Objects;
&nbsp;
&nbsp;import io.telicent.jena.abac.attributes.AttributeSyntaxError;
&nbsp;import org.apache.jena.atlas.AtlasException;
&nbsp;import org.apache.jena.atlas.io.IO;
&nbsp;import org.apache.jena.atlas.io.PeekReader;
&nbsp;import org.apache.jena.riot.system.ErrorHandler;
&nbsp;
&nbsp;/**
&nbsp; * Tokenizer for the ABAC Attribute Labels.
&nbsp; * Supports addition tokens.
&nbsp; * Derived from TokenizerText in Jena.
&nbsp; * Label tokenizing is a much simpler task.
&nbsp; */
&nbsp;public final class TokenizerABAC implements Tokenizer
&nbsp;{
&nbsp;    // Drop through to final general symbol/keyword reader, including &lt;=, !=
&nbsp;    // Care with &lt;=
&nbsp;
<b class="fc">&nbsp;    private Token token = null;</b>
<b class="fc">&nbsp;    private final StringBuilder stringBuilder = new StringBuilder(200);</b>
&nbsp;    private final PeekReader reader;
&nbsp;    // Whether whitespace between tokens includes newlines (in various forms).
&nbsp;    private final boolean lineMode;
<b class="fc">&nbsp;    private boolean finished = false;</b>
&nbsp;
&nbsp;    // Not in jena 4.5.0, Replace at 4.6.0
&nbsp;    private static final char CH_EMARK        = &#39;!&#39; ;
&nbsp;
&nbsp;    // The code assumes that errors throw exception and so stop parsing.
&nbsp;    private final ErrorHandler errorHandler;
&nbsp;
<b class="fc">&nbsp;    public static TokenizeLabelsBuilder create() { return new TokenizeLabelsBuilder() ; }</b>
&nbsp;
<b class="fc">&nbsp;    public static Tokenizer fromString(String string) { return create().fromString(string).build(); }</b>
&nbsp;
&nbsp;    /*package*/ static TokenizerABAC internal(PeekReader reader, boolean lineMode, ErrorHandler errorHandler) {
<b class="fc">&nbsp;        return new TokenizerABAC(reader, lineMode, errorHandler);</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    private TokenizerABAC(PeekReader reader, boolean lineMode, ErrorHandler errorHandler) {</b>
<b class="fc">&nbsp;        this.reader = Objects.requireNonNull(reader, &quot;PeekReader&quot;);</b>
<b class="fc">&nbsp;        this.lineMode = lineMode;</b>
<b class="fc">&nbsp;        this.errorHandler = Objects.requireNonNull(errorHandler, &quot;ErrorHandler&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public final boolean hasNext() {
<b class="fc">&nbsp;        if ( finished )</b>
<b class="fc">&nbsp;            return false;</b>
<b class="fc">&nbsp;        if ( token != null )</b>
<b class="fc">&nbsp;            return true;</b>
&nbsp;
&nbsp;        try {
<b class="fc">&nbsp;            skip();</b>
<b class="fc">&nbsp;            if ( reader.eof() ) {</b>
&nbsp;                // close();
<b class="fc">&nbsp;                finished = true;</b>
<b class="fc">&nbsp;                return false;</b>
&nbsp;            }
<b class="fc">&nbsp;            token = parseToken();</b>
<b class="pc">&nbsp;            if ( token == null ) {</b>
&nbsp;                // close();
<b class="nc">&nbsp;                finished = true;</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
<b class="fc">&nbsp;            return true;</b>
<b class="nc">&nbsp;        } catch (AtlasException ex) {</b>
<b class="nc">&nbsp;            if ( ex.getCause() != null ) {</b>
<b class="nc">&nbsp;                if ( ex.getCause().getClass() == java.nio.charset.MalformedInputException.class )</b>
<b class="nc">&nbsp;                    error(&quot;Bad character encoding&quot;, reader.getLineNum(), reader.getColNum());</b>
<b class="nc">&nbsp;                error(&quot;Bad input stream [&quot; + ex.getCause() + &quot;]&quot;, reader.getLineNum(), reader.getColNum());</b>
&nbsp;            }
<b class="nc">&nbsp;            error(&quot;Bad input stream&quot;, reader.getLineNum(), reader.getColNum());</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public final boolean eof() {
<b class="fc">&nbsp;        return !hasNext();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public final Token next() {
<b class="pc">&nbsp;        if ( !hasNext() )</b>
<b class="nc">&nbsp;            throw new NoSuchElementException();</b>
<b class="fc">&nbsp;        Token t = token;</b>
<b class="fc">&nbsp;        token = null;</b>
<b class="fc">&nbsp;        return t;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public final Token peek() {
<b class="fc">&nbsp;        if ( !hasNext() )</b>
<b class="fc">&nbsp;            return null;</b>
<b class="fc">&nbsp;        return token;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void close() {
<b class="nc">&nbsp;        IO.close(reader);</b>
&nbsp;    }
&nbsp;
&nbsp;    // ---- Machinery
&nbsp;
&nbsp;    private void skip() {
<b class="fc">&nbsp;        int ch = EOF;</b>
&nbsp;        for (;;) {
<b class="fc">&nbsp;            if ( reader.eof() )</b>
&nbsp;                return;
&nbsp;
<b class="fc">&nbsp;            ch = reader.peekChar();</b>
<b class="pc">&nbsp;            if ( ch == CH_HASH ) {</b>
<b class="nc">&nbsp;                reader.readChar();</b>
&nbsp;                // Comment. Skip to NL
&nbsp;                for (;;) {
<b class="nc">&nbsp;                    ch = reader.peekChar();</b>
<b class="nc">&nbsp;                    if ( ch == EOF || isNewlineChar(ch) )</b>
&nbsp;                        break;
<b class="nc">&nbsp;                    reader.readChar();</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            // Including excess newline chars from comment.
<b class="pc">&nbsp;            if ( lineMode ) {</b>
<b class="nc">&nbsp;                if ( !isHorizontalWhitespace(ch) )</b>
&nbsp;                    break;
&nbsp;            } else {
<b class="fc">&nbsp;                if ( !isWhitespace(ch) )</b>
&nbsp;                    break;
&nbsp;            }
<b class="fc">&nbsp;            reader.readChar();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private Token parseToken() {
<b class="fc">&nbsp;        token = new Token(getLine(), getColumn());</b>
&nbsp;
<b class="fc">&nbsp;        int ch = reader.peekChar();</b>
&nbsp;
&nbsp;//        // ---- IRI
&nbsp;//        // Maybe switch to &quot;longest wins&quot;
&nbsp;//        if ( ch == CH_LT ) {
&nbsp;//            // Look ahead on char
&nbsp;//            reader.readChar();
&nbsp;//            int chPeek = reader.peekChar();
&nbsp;//            // not &#39;=&#39;, or space
&nbsp;//            if ( chPeek != &#39; &#39; &amp;&amp; chPeek != &#39;=&#39; ) {
&nbsp;//                token.setImage(readIRI());
&nbsp;//                token.setType(TokenType.IRI);
&nbsp;//                return token;
&nbsp;//            }
&nbsp;//            // Dropthrough.
&nbsp;//            reader.pushbackChar(CH_LT);
&nbsp;//            //fatal(&quot;Internal error - parsed &#39;%c&#39; after &#39;&lt;&#39;&quot;, chPeek);
&nbsp;//        }
&nbsp;
&nbsp;        // ---- Literal
<b class="fc">&nbsp;        if ( ch == CH_QUOTE1 || ch == CH_QUOTE2 ) {</b>
&nbsp;            // The token type is STRING.
&nbsp;            // We incorporate this into a token for LITERAL_LANG or LITERAL_DT.
<b class="fc">&nbsp;            token.setType(TokenType.STRING);</b>
&nbsp;
<b class="fc">&nbsp;            reader.readChar();</b>
<b class="fc">&nbsp;            int ch2 = reader.peekChar();</b>
<b class="pc">&nbsp;            if ( ch2 == ch ) {</b>
<b class="nc">&nbsp;                reader.readChar(); // Read potential second quote.</b>
<b class="nc">&nbsp;                int ch3 = reader.peekChar();</b>
<b class="nc">&nbsp;                if ( ch3 == ch ) {</b>
<b class="nc">&nbsp;                    reader.readChar();     // Read potential third quote.</b>
<b class="nc">&nbsp;                    token.setImage(readLongString(ch, false));</b>
<b class="nc">&nbsp;                    StringType st = (ch == CH_QUOTE1) ? StringType.LONG_STRING1 : StringType.LONG_STRING2;</b>
<b class="nc">&nbsp;                    token.setStringType(st);</b>
&nbsp;                } else {
&nbsp;                    // Two quotes then a non-quote.
&nbsp;                    // Must be &#39;&#39; or &quot;&quot;
&nbsp;                    // No need to pushback characters as we know the lexical
&nbsp;                    // form is the empty string.
&nbsp;                    // if ( ch2 != EOF ) reader.pushbackChar(ch2);
&nbsp;                    // if ( ch1 != EOF ) reader.pushbackChar(ch1); // Must be
&nbsp;                    // &#39;&#39; or &quot;&quot;
<b class="nc">&nbsp;                    token.setImage(&quot;&quot;);</b>
<b class="nc">&nbsp;                    StringType st = (ch == CH_QUOTE1) ? StringType.STRING1 : StringType.STRING2;</b>
<b class="nc">&nbsp;                    token.setStringType(st);</b>
&nbsp;                }
&nbsp;            } else {
&nbsp;                // One quote character.
<b class="fc">&nbsp;                token.setImage(readString(ch, ch));</b>
&nbsp;                // Record exactly what form of STRING was seen.
<b class="fc">&nbsp;                StringType st = (ch == CH_QUOTE1) ? StringType.STRING1 : StringType.STRING2;</b>
<b class="fc">&nbsp;                token.setStringType(st);</b>
&nbsp;            }
<b class="fc">&nbsp;            return token;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Other single and start chars.
<b class="pc">&nbsp;        switch(ch)</b>
&nbsp;        {
<b class="nc">&nbsp;            case CH_SEMICOLON:  return oneChar(TokenType.SEMICOLON, CH_SEMICOLON);</b>
<b class="fc">&nbsp;            case CH_COMMA:      return oneChar(TokenType.COMMA, CH_COMMA);</b>
&nbsp;
<b class="fc">&nbsp;            case CH_LBRACE:     return oneChar(TokenType.LBRACE, CH_LBRACE);</b>
<b class="fc">&nbsp;            case CH_RBRACE:     return oneChar(TokenType.RBRACE, CH_RBRACE);</b>
&nbsp;
<b class="fc">&nbsp;            case CH_LPAREN:     return oneChar(TokenType.LPAREN, CH_LPAREN);</b>
<b class="fc">&nbsp;            case CH_RPAREN:     return oneChar(TokenType.RPAREN, CH_RPAREN);</b>
<b class="nc">&nbsp;            case CH_LBRACKET:   return oneChar(TokenType.LBRACKET, CH_LBRACKET);</b>
<b class="nc">&nbsp;            case CH_RBRACKET:   return oneChar(TokenType.RBRACKET, CH_RBRACKET);</b>
&nbsp;
<b class="nc">&nbsp;            case CH_SLASH:      return oneChar(TokenType.SLASH, CH_SLASH);</b>
<b class="fc">&nbsp;            case CH_RSLASH:     return oneChar(TokenType.RSLASH, CH_RSLASH);</b>
&nbsp;
<b class="fc">&nbsp;            case CH_COLON:      return oneChar(TokenType.COLON, CH_COLON);</b>
<b class="fc">&nbsp;            case CH_STAR:       return oneChar(TokenType.STAR, CH_STAR);</b>
<b class="nc">&nbsp;            case CH_QMARK:      return oneChar(TokenType.QMARK, CH_QMARK);</b>
&nbsp;
&nbsp;            // Multi-character symbols
&nbsp;            // Two character tokens : !=, GE &gt;= , LE &lt;=, &amp;&amp;, ||
<b class="fc">&nbsp;            case CH_EQUALS:     return maybeTwoChar(CH_EQUALS, &#39;=&#39;, TokenType.EQ, &quot;=&quot;, TokenType.EQUIVALENT, &quot;==&quot;);</b>
<b class="fc">&nbsp;            case CH_EMARK:      return maybeTwoChar(CH_EMARK, &#39;=&#39;, TokenType.EMARK, &quot;!&quot;, TokenType.NE, &quot;!=&quot;);</b>
<b class="fc">&nbsp;            case CH_LT:         return maybeTwoChar(CH_LT, &#39;=&#39;, TokenType.LT, &quot;&lt;&quot;, TokenType.LE, &quot;&lt;=&quot;);</b>
<b class="fc">&nbsp;            case CH_GT:         return maybeTwoChar(CH_GT, &#39;=&#39;, TokenType.GT, &quot;&gt;&quot;, TokenType.GE, &quot;&gt;=&quot;);</b>
&nbsp;
<b class="fc">&nbsp;            case CH_VBAR:       return maybeTwoChar(CH_VBAR, &#39;|&#39;, TokenType.VBAR, &quot;|&quot;, TokenType.LOGICAL_OR, &quot;||&quot;);</b>
<b class="fc">&nbsp;            case CH_AMPHERSAND: return maybeTwoChar(CH_AMPHERSAND, &#39;&amp;&#39;, TokenType.AMPERSAND, &quot;&amp;&quot;, TokenType.LOGICAL_AND, &quot;&amp;&amp;&quot;);</b>
&nbsp;        }
&nbsp;
<b class="pc">&nbsp;        if ( isNewlineChar(ch) ) {</b>
&nbsp;            do {
<b class="nc">&nbsp;                int ch2 = reader.readChar();</b>
&nbsp;                // insertCodepointDirect(stringBuilder,ch2);
<b class="nc">&nbsp;            } while (isNewlineChar(reader.peekChar()));</b>
<b class="nc">&nbsp;            token.setType(TokenType.NL);</b>
&nbsp;            //** token.setImage(stringBuilder.toString());
<b class="nc">&nbsp;            return token;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Numbers - maybe.
&nbsp;        /*
&nbsp;         * Turtle syntax rules.
&nbsp;            integer         ::=     (&#39;-&#39; | &#39;+&#39;) ? [0-9]+
&nbsp;            double          ::=     (&#39;-&#39; | &#39;+&#39;) ? ( [0-9]+ &#39;.&#39; [0-9]* exponent | &#39;.&#39; ([0-9])+ exponent | ([0-9])+ exponent )
&nbsp;            decimal         ::=     (&#39;-&#39; | &#39;+&#39;)? ( [0-9]+ &#39;.&#39; [0-9]* | &#39;.&#39; ([0-9])+ | ([0-9])+ )
&nbsp;                                        0.0 .0 0.
&nbsp;        [19]    exponent        ::=     [eE] (&#39;-&#39; | &#39;+&#39;)? [0-9]+
&nbsp;        []      hex             ::=     0x0123456789ABCDEFG
&nbsp;        */
<b class="fc">&nbsp;        if ( ch == CH_PLUS || ch == CH_MINUS ) {</b>
<b class="fc">&nbsp;            reader.readChar();</b>
&nbsp;            // Peek for base plus and minus.
<b class="fc">&nbsp;            int ch2 = reader.peekChar();</b>
&nbsp;
<b class="fc">&nbsp;            if ( !range(ch2, &#39;0&#39;, &#39;9&#39;) ) {</b>
&nbsp;                // ch was end of symbol.
&nbsp;                // reader.readChar();
<b class="fc">&nbsp;                if ( ch == CH_PLUS )</b>
<b class="fc">&nbsp;                    token.setType(TokenType.PLUS);</b>
&nbsp;                else
<b class="fc">&nbsp;                    token.setType(TokenType.MINUS);</b>
<b class="fc">&nbsp;                return token;</b>
&nbsp;            }
&nbsp;            // Fall through
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if ( ch == CH_PLUS || ch == CH_MINUS || range(ch, &#39;0&#39;, &#39;9&#39;) ) {</b>
&nbsp;            // readNumberNoSign
<b class="fc">&nbsp;            readNumber();</b>
<b class="fc">&nbsp;            return token;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Plain words
<b class="fc">&nbsp;        if ( Words.isWordStart(ch) ) {</b>
<b class="fc">&nbsp;            String str = readWord();</b>
<b class="fc">&nbsp;            token.setType(TokenType.WORD);</b>
<b class="fc">&nbsp;            token.setImage(str);</b>
<b class="fc">&nbsp;            return token;</b>
&nbsp;        }
<b class="fc">&nbsp;        fatal(&quot;Bad character: %c&quot;, (char)ch);</b>
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    private Token oneChar(TokenType tokenType, char character) {
<b class="fc">&nbsp;        reader.readChar();</b>
<b class="fc">&nbsp;        token.setType(tokenType);</b>
<b class="fc">&nbsp;        token.setImage(character);</b>
<b class="fc">&nbsp;        return token;</b>
&nbsp;    }
&nbsp;
&nbsp;    private Token maybeTwoChar(char ch1, char secondChar, TokenType oneCharToken, String oneCharStr, TokenType twoCharToken, String twoCharStr) {
<b class="fc">&nbsp;        reader.readChar();</b>
<b class="fc">&nbsp;        int ch2 = reader.peekChar();</b>
<b class="fc">&nbsp;        if ( ch2 == secondChar ) {</b>
<b class="fc">&nbsp;            reader.readChar();</b>
<b class="fc">&nbsp;            token.setType(twoCharToken);</b>
<b class="fc">&nbsp;            token.setImage(twoCharStr);</b>
<b class="fc">&nbsp;            return token;</b>
&nbsp;        }
<b class="fc">&nbsp;        token.setType(oneCharToken);</b>
<b class="fc">&nbsp;        token.setImage(oneCharStr);</b>
<b class="fc">&nbsp;        return token;</b>
&nbsp;    }
&nbsp;
&nbsp;    private static final boolean VeryVeryLaxIRI = false;
&nbsp;    // Spaces in IRI are illegal.
&nbsp;    private static final boolean AllowSpacesInIRI = false;
&nbsp;
&nbsp;    // [8]  IRIREF  ::= &#39;&lt;&#39; ([^#x00-#x20&lt;&gt;&quot;{}|^`\] | UCHAR)* &#39;&gt;&#39;
&nbsp;    private String readIRI() {
<b class="nc">&nbsp;        stringBuilder.setLength(0);</b>
&nbsp;        for (;;) {
<b class="nc">&nbsp;            int ch = reader.readChar();</b>
<b class="nc">&nbsp;            switch(ch) {</b>
&nbsp;                case EOF:
<b class="nc">&nbsp;                    fatal(&quot;Broken IRI (End of file)&quot;); return null;</b>
&nbsp;                case NL:
<b class="nc">&nbsp;                    fatal(&quot;Broken IRI (newline): %s&quot;, stringBuilder.toString()); return null;</b>
&nbsp;                case CR:
<b class="nc">&nbsp;                    fatal(&quot;Broken IRI (CR): %s&quot;, stringBuilder.toString()); return null;</b>
&nbsp;                case CH_GT:
&nbsp;                    // Done!
<b class="nc">&nbsp;                    return stringBuilder.toString();</b>
&nbsp;                case CH_RSLASH:
&nbsp;                    if ( VeryVeryLaxIRI )
&nbsp;                        // Includes unicode escapes and also \n etc
&nbsp;                        ch = readLiteralEscape();
&nbsp;                    else
&nbsp;                        // NORMAL
<b class="nc">&nbsp;                        ch = readUnicodeEscape();</b>
&nbsp;                    // Don&#39;t check legality of ch (strict syntax at this point).
&nbsp;                    // That does not mean it is a good idea to bypass checking.
&nbsp;                    // Bad characters will lead to trouble elsewhere.
&nbsp;                    break;
&nbsp;                case CH_LT:
&nbsp;                    // Probably a corrupt file so treat as fatal.
<b class="nc">&nbsp;                    fatal(&quot;Bad character in IRI (bad character: &#39;&lt;&#39;): &lt;%s[&lt;]...&gt;&quot;, stringBuilder.toString()); return null;</b>
&nbsp;                case TAB:
<b class="nc">&nbsp;                    error(&quot;Bad character in IRI (Tab character): &lt;%s[tab]...&gt;&quot;, stringBuilder.toString()); return null;</b>
&nbsp;                case &#39;{&#39;: case &#39;}&#39;: case &#39;&quot;&#39;: case &#39;|&#39;: case &#39;^&#39;: case &#39;`&#39; :
&nbsp;                    if ( ! VeryVeryLaxIRI )
<b class="nc">&nbsp;                        warning(&quot;Illegal character in IRI (codepoint 0x%02X, &#39;%c&#39;): &lt;%s[%c]...&gt;&quot;, ch, (char)ch, stringBuilder.toString(), (char)ch);</b>
&nbsp;                    break;
&nbsp;                case SPC:
&nbsp;                    if ( ! AllowSpacesInIRI )
<b class="nc">&nbsp;                        error(&quot;Bad character in IRI (space): &lt;%s[space]...&gt;&quot;, stringBuilder.toString());</b>
&nbsp;                    else
&nbsp;                        warning(&quot;Bad character in IRI (space): &lt;%s[space]...&gt;&quot;, stringBuilder.toString());
&nbsp;                    break;
&nbsp;                default:
<b class="nc">&nbsp;                    if ( ch &lt;= 0x19 )</b>
<b class="nc">&nbsp;                        warning(&quot;Illegal character in IRI (control char 0x%02X): &lt;%s[0x%02X]...&gt;&quot;, ch, stringBuilder.toString(), ch);</b>
&nbsp;
&nbsp;            }
<b class="nc">&nbsp;            if ( ! VeryVeryLaxIRI &amp;&amp; ch &gt;= 0xA0 &amp;&amp; ! isUcsChar(ch) )</b>
<b class="nc">&nbsp;                warning(&quot;Illegal character in IRI (Not a ucschar: 0x%04X): &lt;%s[U+%04X]...&gt;&quot;, ch, stringBuilder.toString(), ch);</b>
<b class="nc">&nbsp;            insertCodepoint(stringBuilder, ch);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static boolean isUcsChar(int ch) {
&nbsp;        // RFC 3987
&nbsp;        // ucschar    = %xA0-D7FF / %xF900-FDCF / %xFDF0-FFEF
&nbsp;        //            / %x10000-1FFFD / %x20000-2FFFD / %x30000-3FFFD
&nbsp;        //            / %x40000-4FFFD / %x50000-5FFFD / %x60000-6FFFD
&nbsp;        //            / %x70000-7FFFD / %x80000-8FFFD / %x90000-9FFFD
&nbsp;        //            / %xA0000-AFFFD / %xB0000-BFFFD / %xC0000-CFFFD
&nbsp;        //            / %xD0000-DFFFD / %xE1000-EFFFD
<b class="nc">&nbsp;        boolean b = range(ch, 0xA0, 0xD7FF)  || range(ch, 0xF900, 0xFDCF)  || range(ch, 0xFDF0, 0xFFEF);</b>
<b class="nc">&nbsp;        if ( b )</b>
<b class="nc">&nbsp;            return true;</b>
<b class="nc">&nbsp;        if ( ch &lt; 0x1000 )</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        // 32 bit checks.
<b class="nc">&nbsp;        return</b>
<b class="nc">&nbsp;            range(ch, 0x10000, 0x1FFFD) || range(ch, 0x20000, 0x2FFFD) || range(ch, 0x30000, 0x3FFFD) ||</b>
<b class="nc">&nbsp;            range(ch, 0x40000, 0x4FFFD) || range(ch, 0x50000, 0x5FFFD) || range(ch, 0x60000, 0x6FFFD) ||</b>
<b class="nc">&nbsp;            range(ch, 0x70000, 0x7FFFD) || range(ch, 0x80000, 0x8FFFD) || range(ch, 0x90000, 0x9FFFD) ||</b>
<b class="nc">&nbsp;            range(ch, 0xA0000, 0xAFFFD) || range(ch, 0xB0000, 0xBFFFD) || range(ch, 0xC0000, 0xCFFFD) ||</b>
<b class="nc">&nbsp;            range(ch, 0xD0000, 0xDFFFD) || range(ch, 0xE1000, 0xEFFFD);</b>
&nbsp;    }
&nbsp;
&nbsp;    // Read a unicode escape : does not allow \\ bypass
&nbsp;    private final int readUnicodeEscape() {
<b class="nc">&nbsp;        int ch = reader.readChar();</b>
<b class="nc">&nbsp;        if ( ch == EOF )</b>
<b class="nc">&nbsp;            fatal(&quot;Broken escape sequence&quot;);</b>
&nbsp;
<b class="nc">&nbsp;        switch (ch) {</b>
<b class="nc">&nbsp;            case &#39;u&#39;: return readUnicode4Escape();</b>
<b class="nc">&nbsp;            case &#39;U&#39;: return readUnicode8Escape();</b>
&nbsp;            default:
<b class="nc">&nbsp;                fatal(&quot;Illegal unicode escape sequence value: \\%c (0x%02X)&quot;, ch, ch);</b>
&nbsp;        }
<b class="nc">&nbsp;        return 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    // Get characters between two markers.
&nbsp;    // strEscapes may be processed
&nbsp;    private String readString(int startCh, int endCh) {
&nbsp;        // Position at start of string.
<b class="fc">&nbsp;        stringBuilder.setLength(0);</b>
&nbsp;        // Assumes first delimiter char read already.
&nbsp;        // Reads terminating delimiter
&nbsp;
&nbsp;        for (;;) {
<b class="fc">&nbsp;            int ch = reader.readChar();</b>
&nbsp;
&nbsp;            // Raw replacement char in a string.
<b class="pc">&nbsp;            if ( ch == REPLACEMENT )</b>
<b class="nc">&nbsp;                warning(&quot;Unicode replacement character U+FFFD in string&quot;);</b>
<b class="pc">&nbsp;            else if ( ch == EOF ) {</b>
&nbsp;                // if ( endNL ) return stringBuilder.toString();
<b class="nc">&nbsp;                fatal(&quot;Broken token: %s&quot;, stringBuilder.toString());</b>
&nbsp;            }
<b class="pc">&nbsp;            else if ( ch == NL )</b>
<b class="nc">&nbsp;                fatal(&quot;Broken token (newline): %s&quot;, stringBuilder.toString());</b>
<b class="fc">&nbsp;            else if ( ch == endCh )</b>
<b class="fc">&nbsp;                return stringBuilder.toString();</b>
<b class="fc">&nbsp;            else if ( ch == CH_RSLASH )</b>
&nbsp;                // Allow escaped replacement character.
<b class="fc">&nbsp;                ch = readLiteralEscape();</b>
&nbsp;
<b class="fc">&nbsp;            insertCodepoint(stringBuilder, ch);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private String readLongString(int quoteChar, boolean endNL) {
<b class="nc">&nbsp;        stringBuilder.setLength(0);</b>
&nbsp;        for (;;) {
<b class="nc">&nbsp;            int ch = reader.readChar();</b>
<b class="nc">&nbsp;            if ( ch == REPLACEMENT )</b>
<b class="nc">&nbsp;                warning(&quot;Input has Unicode replacement character U+FFFD in string&quot;);</b>
<b class="nc">&nbsp;            else if ( ch == EOF ) {</b>
<b class="nc">&nbsp;                if ( endNL )</b>
<b class="nc">&nbsp;                    return stringBuilder.toString();</b>
<b class="nc">&nbsp;                fatal(&quot;Broken long string&quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;            else if ( ch == quoteChar ) {</b>
<b class="nc">&nbsp;                if ( threeQuotes(quoteChar) )</b>
<b class="nc">&nbsp;                    return stringBuilder.toString();</b>
<b class="nc">&nbsp;            } else if ( ch == CH_RSLASH )</b>
<b class="nc">&nbsp;                ch = readLiteralEscape();</b>
<b class="nc">&nbsp;            insertCodepoint(stringBuilder, ch);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    // Assume we have read the first quote char.
&nbsp;    // On return:
&nbsp;    //   If false, have moved over no more characters (due to pushbacks)
&nbsp;    //   If true, at end of 3 quotes
&nbsp;    private boolean threeQuotes(int ch) {
&nbsp;        // reader.readChar(); // Read first quote.
<b class="nc">&nbsp;        int ch2 = reader.peekChar();</b>
<b class="nc">&nbsp;        if ( ch2 != ch ) {</b>
&nbsp;            // reader.pushbackChar(ch2);
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        reader.readChar(); // Read second quote.</b>
<b class="nc">&nbsp;        int ch3 = reader.peekChar();</b>
<b class="nc">&nbsp;        if ( ch3 != ch ) {</b>
&nbsp;            // reader.pushbackChar(ch3);
<b class="nc">&nbsp;            reader.pushbackChar(ch2);</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Three quotes.
<b class="nc">&nbsp;        reader.readChar(); // Read third quote.</b>
<b class="nc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;     * [146]  INTEGER  ::=  [0-9]+
&nbsp;     * [147]  DECIMAL  ::=  [0-9]* &#39;.&#39; [0-9]+
&nbsp;     * [148]  DOUBLE  ::=  [0-9]+ &#39;.&#39; [0-9]* EXPONENT | &#39;.&#39; ([0-9])+ EXPONENT | ([0-9])+ EXPONENT
&nbsp;     * []     hex             ::=     0x0123456789ABCDEFG
&nbsp;     */
&nbsp;    private void readNumber() {
&nbsp;        // One entry, definitely a number.
&nbsp;        // Already dealt with &#39;.&#39; as a (non) decimal.
<b class="fc">&nbsp;        boolean isDouble = false;</b>
<b class="fc">&nbsp;        boolean isDecimal = false;</b>
<b class="fc">&nbsp;        stringBuilder.setLength(0);</b>
&nbsp;
<b class="fc">&nbsp;        int x = 0; // Digits before a dot.</b>
<b class="fc">&nbsp;        int ch = reader.peekChar();</b>
<b class="fc">&nbsp;        if ( ch == &#39;0&#39; ) {</b>
<b class="fc">&nbsp;            x++;</b>
<b class="fc">&nbsp;            reader.readChar();</b>
<b class="fc">&nbsp;            insertCodepointDirect(stringBuilder, ch);</b>
<b class="fc">&nbsp;            ch = reader.peekChar();</b>
<b class="pc">&nbsp;            if ( ch == &#39;x&#39; || ch == &#39;X&#39; ) {</b>
<b class="fc">&nbsp;                reader.readChar();</b>
<b class="fc">&nbsp;                insertCodepointDirect(stringBuilder, ch);</b>
<b class="fc">&nbsp;                readHex(reader, stringBuilder);</b>
<b class="fc">&nbsp;                token.setImage(stringBuilder.toString());</b>
<b class="fc">&nbsp;                token.setType(TokenType.HEX);</b>
&nbsp;                return;
&nbsp;            }
<b class="pc">&nbsp;        } else if ( ch == &#39;-&#39; || ch == &#39;+&#39; ) {</b>
<b class="nc">&nbsp;            readPossibleSign(stringBuilder);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        x += readDigits(stringBuilder);</b>
<b class="fc">&nbsp;        ch = reader.peekChar();</b>
<b class="fc">&nbsp;        if ( ch == CH_DOT ) {</b>
<b class="fc">&nbsp;            reader.readChar();</b>
<b class="fc">&nbsp;            stringBuilder.append(CH_DOT);</b>
<b class="fc">&nbsp;            isDecimal = true; // Includes things that will be doubles.</b>
<b class="fc">&nbsp;            readDigits(stringBuilder);</b>
&nbsp;        }
&nbsp;
<b class="pc">&nbsp;        if ( x == 0 &amp;&amp; !isDecimal )</b>
&nbsp;            // Possible a tokenizer error - should not have entered readNumber
&nbsp;            // in the first place.
<b class="nc">&nbsp;            fatal(&quot;Unrecognized as number&quot;);</b>
&nbsp;
<b class="fc">&nbsp;        if ( exponent(stringBuilder) ) {</b>
<b class="fc">&nbsp;            isDouble = true;</b>
<b class="fc">&nbsp;            isDecimal = false;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Final part - &quot;decimal&quot; 123. is an integer 123 and a DOT.
<b class="fc">&nbsp;        if ( isDecimal ) {</b>
<b class="fc">&nbsp;            int len = stringBuilder.length();</b>
<b class="pc">&nbsp;            if ( stringBuilder.charAt(len - 1) == CH_DOT ) {</b>
<b class="nc">&nbsp;                stringBuilder.setLength(len - 1);</b>
<b class="nc">&nbsp;                reader.pushbackChar(CH_DOT);</b>
<b class="nc">&nbsp;                isDecimal = false;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        token.setImage(stringBuilder.toString());</b>
<b class="fc">&nbsp;        if ( isDouble )</b>
<b class="fc">&nbsp;            token.setType(TokenType.DOUBLE);</b>
<b class="fc">&nbsp;        else if ( isDecimal )</b>
<b class="fc">&nbsp;            token.setType(TokenType.DECIMAL);</b>
&nbsp;        else
<b class="fc">&nbsp;            token.setType(TokenType.INTEGER);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void readHex(PeekReader reader, StringBuilder sb) {
&nbsp;        // Just after the 0x, which are in sb
<b class="fc">&nbsp;        int x = 0;</b>
&nbsp;        for (;;) {
<b class="fc">&nbsp;            int ch = reader.peekChar();</b>
<b class="fc">&nbsp;            if ( !isHexChar(ch) )</b>
&nbsp;                break;
<b class="fc">&nbsp;            reader.readChar();</b>
<b class="fc">&nbsp;            insertCodepointDirect(sb, ch);</b>
<b class="fc">&nbsp;            x++;</b>
&nbsp;        }
<b class="fc">&nbsp;        if ( x == 0 )</b>
<b class="fc">&nbsp;            fatal(&quot;No hex characters after %s&quot;, sb.toString());</b>
&nbsp;    }
&nbsp;
&nbsp;    private int readDigits(StringBuilder buffer) {
<b class="fc">&nbsp;        int count = 0;</b>
&nbsp;        for (;;) {
<b class="fc">&nbsp;            int ch = reader.peekChar();</b>
<b class="fc">&nbsp;            if ( !range(ch, &#39;0&#39;, &#39;9&#39;) )</b>
&nbsp;                break;
<b class="fc">&nbsp;            reader.readChar();</b>
<b class="fc">&nbsp;            insertCodepointDirect(buffer, ch);</b>
<b class="fc">&nbsp;            count++;</b>
&nbsp;        }
<b class="fc">&nbsp;        return count;</b>
&nbsp;    }
&nbsp;
&nbsp;    private void readPossibleSign(StringBuilder sb) {
<b class="fc">&nbsp;        int ch = reader.peekChar();</b>
<b class="fc">&nbsp;        if ( ch == &#39;-&#39; || ch == &#39;+&#39; ) {</b>
<b class="fc">&nbsp;            reader.readChar();</b>
<b class="fc">&nbsp;            insertCodepointDirect(sb, ch);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private boolean exponent(StringBuilder sb) {
<b class="fc">&nbsp;        int ch = reader.peekChar();</b>
<b class="fc">&nbsp;        if ( ch != &#39;e&#39; &amp;&amp; ch != &#39;E&#39; )</b>
<b class="fc">&nbsp;            return false;</b>
<b class="fc">&nbsp;        reader.readChar();</b>
<b class="fc">&nbsp;        insertCodepointDirect(sb, ch);</b>
<b class="fc">&nbsp;        readPossibleSign(sb);</b>
<b class="fc">&nbsp;        int x = readDigits(sb);</b>
<b class="pc">&nbsp;        if ( x == 0 )</b>
<b class="nc">&nbsp;            fatal(&quot;Malformed double: %s&quot;, sb);</b>
<b class="fc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    // -- Words, processed as a string of characters.
&nbsp;    // First character has been verified but not read yet.
&nbsp;    private String readWord() {
&nbsp;        // First char
<b class="fc">&nbsp;        int firstCh = reader.readChar();</b>
&nbsp;        //if ( ! Words.isWordStart(firstCh) ) {}
&nbsp;
<b class="fc">&nbsp;        stringBuilder.setLength(0);</b>
<b class="fc">&nbsp;        insertCodepoint(stringBuilder, firstCh);</b>
&nbsp;        // First char is valid last char.
<b class="fc">&nbsp;        int idx = 0;</b>
&nbsp;        // Remember the index of the last seen character that is legal as a last character.
<b class="fc">&nbsp;        int lastValidLastChar = 0;</b>
&nbsp;        // Loop:middle and last character.
<b class="fc">&nbsp;        int chRead = EOF;</b>
&nbsp;        for (;;) {
<b class="fc">&nbsp;            int ch = reader.peekChar();</b>
<b class="fc">&nbsp;            if ( ch == EOF )</b>
&nbsp;                break;
<b class="fc">&nbsp;            if ( ! Words.isWordMiddle(ch) )</b>
&nbsp;                break;
&nbsp;
<b class="fc">&nbsp;            chRead = reader.readChar();</b>
<b class="fc">&nbsp;            idx++;</b>
<b class="fc">&nbsp;            insertCodepointDirect(stringBuilder, chRead);</b>
<b class="fc">&nbsp;            if ( Words.isWordEnd(ch) )</b>
<b class="fc">&nbsp;                lastValidLastChar = idx;</b>
&nbsp;            // Loop
&nbsp;        }
&nbsp;
&nbsp;        // Delete: note first character was valid
<b class="fc">&nbsp;        if ( chRead != EOF &amp;&amp; lastValidLastChar != idx ) {</b>
&nbsp;            // Move backwards.
<b class="fc">&nbsp;            for ( int i = idx ; i &gt; lastValidLastChar ; i-- ) {</b>
<b class="fc">&nbsp;                int ch = stringBuilder.charAt(i);</b>
<b class="fc">&nbsp;                stringBuilder.deleteCharAt(i);</b>
<b class="fc">&nbsp;                reader.pushbackChar(chRead);</b>
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;        return stringBuilder.toString();</b>
&nbsp;    }
&nbsp;
&nbsp;    // --
&nbsp;
&nbsp;    private void insertCodepoint(StringBuilder buffer, int ch) {
<b class="pc">&nbsp;        if ( Character.charCount(ch) == 1 )</b>
<b class="fc">&nbsp;            insertCodepointDirect(buffer, ch);</b>
&nbsp;        else {
&nbsp;            // Convert to UTF-16. Note that the rest of any system this is used
&nbsp;            // in must also respect codepoints and surrogate pairs.
<b class="nc">&nbsp;            if ( !Character.isDefined(ch) &amp;&amp; !Character.isSupplementaryCodePoint(ch) )</b>
<b class="nc">&nbsp;                fatal(&quot;Illegal codepoint: 0x%04X&quot;, ch);</b>
<b class="nc">&nbsp;            char[] chars = Character.toChars(ch);</b>
<b class="nc">&nbsp;            buffer.append(chars);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    // Insert code point, knowing that &#39;ch&#39; is 16 bit (basic plane)
&nbsp;    private static void insertCodepointDirect(StringBuilder buffer, int ch) {
<b class="fc">&nbsp;        buffer.append((char)ch);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public long getColumn() {
<b class="fc">&nbsp;        return reader.getColNum();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public long getLine() {
<b class="fc">&nbsp;        return reader.getLineNum();</b>
&nbsp;    }
&nbsp;
&nbsp;    // ---- Escape sequences
&nbsp;
&nbsp;    private final int readLiteralEscape() {
<b class="fc">&nbsp;        int c = reader.readChar();</b>
<b class="pc">&nbsp;        if ( c == EOF )</b>
<b class="nc">&nbsp;            fatal(&quot;Escape sequence not completed&quot;);</b>
&nbsp;
<b class="pc">&nbsp;        switch (c) {</b>
<b class="nc">&nbsp;            case &#39;n&#39;:   return NL;</b>
<b class="nc">&nbsp;            case &#39;r&#39;:   return CR;</b>
<b class="fc">&nbsp;            case &#39;t&#39;:   return TAB;</b>
<b class="nc">&nbsp;            case &#39;f&#39;:   return &#39;\f&#39;;</b>
<b class="nc">&nbsp;            case &#39;b&#39;:   return BSPACE;</b>
<b class="nc">&nbsp;            case &#39;&quot;&#39;:   return &#39;&quot;&#39;;</b>
<b class="nc">&nbsp;            case &#39;\&#39;&#39;:  return &#39;\&#39;&#39;;</b>
<b class="nc">&nbsp;            case &#39;\\&#39;:  return &#39;\\&#39;;</b>
<b class="fc">&nbsp;            case &#39;u&#39;:   return readUnicode4Escape();</b>
<b class="fc">&nbsp;            case &#39;U&#39;:   return readUnicode8Escape();</b>
&nbsp;            default:
<b class="nc">&nbsp;                fatal(&quot;Illegal escape sequence value: %c (0x%02X)&quot;, c, c);</b>
<b class="nc">&nbsp;                return 0;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private final int readCharEscape() {
&nbsp;        // PN_LOCAL_ESC ::= &#39;\&#39; ( &#39;_&#39; | &#39;~&#39; | &#39;.&#39; | &#39;-&#39; | &#39;!&#39; | &#39;$&#39; | &#39;&amp;&#39; | &quot;&#39;&quot;
&nbsp;        //                | &#39;(&#39; | &#39;)&#39; | &#39;*&#39; | &#39;+&#39; | &#39;,&#39; | &#39;;&#39; | &#39;=&#39; | &#39;/&#39; | &#39;?&#39; | &#39;#&#39; | &#39;@&#39; | &#39;%&#39; )
&nbsp;
<b class="nc">&nbsp;        int c = reader.readChar();</b>
<b class="nc">&nbsp;        if ( c == EOF )</b>
<b class="nc">&nbsp;            fatal(&quot;Escape sequence not completed&quot;);</b>
&nbsp;
<b class="nc">&nbsp;        switch (c) {</b>
&nbsp;            case &#39;_&#39;: case &#39;~&#39;: case &#39;.&#39;:  case &#39;-&#39;:  case &#39;!&#39;:  case &#39;$&#39;:  case &#39;&amp;&#39;:
&nbsp;            case &#39;\&#39;&#39;:
&nbsp;            case &#39;(&#39;:  case &#39;)&#39;:  case &#39;*&#39;:  case &#39;+&#39;:  case &#39;,&#39;:  case &#39;;&#39;:
&nbsp;            case &#39;=&#39;:  case &#39;/&#39;:  case &#39;?&#39;:  case &#39;#&#39;:  case &#39;@&#39;:  case &#39;%&#39;:
<b class="nc">&nbsp;                return c;</b>
&nbsp;            default:
<b class="nc">&nbsp;                fatal(&quot;illegal character escape value: \\%c&quot;, c);</b>
<b class="nc">&nbsp;                return 0;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private final
<b class="fc">&nbsp;    int readUnicode4Escape() { return readHexSequence(4); }</b>
&nbsp;
&nbsp;    private final int readUnicode8Escape() {
<b class="fc">&nbsp;        int ch8 = readHexSequence(8);</b>
<b class="pc">&nbsp;        if ( ch8 &gt; Character.MAX_CODE_POINT )</b>
<b class="nc">&nbsp;            fatal(&quot;Illegal code point in \\U sequence value: 0x%08X&quot;, ch8);</b>
<b class="fc">&nbsp;        return ch8;</b>
&nbsp;    }
&nbsp;
&nbsp;    private final int readHexSequence(int N) {
<b class="fc">&nbsp;        int x = 0;</b>
<b class="fc">&nbsp;        for (int i = 0; i &lt; N; i++) {</b>
<b class="fc">&nbsp;            int d = readHexChar();</b>
<b class="pc">&nbsp;            if ( d &lt; 0 )</b>
<b class="nc">&nbsp;                return -1;</b>
<b class="fc">&nbsp;            x = (x &lt;&lt; 4) + d;</b>
&nbsp;        }
<b class="fc">&nbsp;        return x;</b>
&nbsp;    }
&nbsp;
&nbsp;    private final int readHexChar() {
<b class="fc">&nbsp;        int ch = reader.readChar();</b>
<b class="pc">&nbsp;        if ( ch == EOF )</b>
<b class="nc">&nbsp;            fatal(&quot;Not a hexadecimal character (end of file)&quot;);</b>
&nbsp;
<b class="fc">&nbsp;        int x = valHexChar(ch);</b>
<b class="pc">&nbsp;        if ( x != -1 )</b>
<b class="fc">&nbsp;            return x;</b>
<b class="nc">&nbsp;        fatal(&quot;Not a hexadecimal character: &#39;%c&#39;&quot;, (char)ch);</b>
<b class="nc">&nbsp;        return -1;</b>
&nbsp;    }
&nbsp;
&nbsp;    private boolean expect(String str) {
<b class="nc">&nbsp;        for (int i = 0; i &lt; str.length(); i++) {</b>
<b class="nc">&nbsp;            char want = str.charAt(i);</b>
<b class="nc">&nbsp;            if ( reader.eof() ) {</b>
<b class="nc">&nbsp;                fatal(&quot;End of input during expected string: %s&quot;, str);</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
<b class="nc">&nbsp;            int inChar = reader.peekChar();</b>
<b class="nc">&nbsp;            if ( inChar != want ) {</b>
<b class="nc">&nbsp;                fatal(&quot;expected \&quot;%s\&quot;&quot;, str);</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
<b class="nc">&nbsp;            reader.readChar();</b>
&nbsp;        }
<b class="nc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Warning - can continue. */
&nbsp;    private void warning(String message, Object... args) {
<b class="nc">&nbsp;        String msg = String.format(message, args);</b>
<b class="nc">&nbsp;        errorHandler.warning(msg, reader.getLineNum(), reader.getColNum());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Error - at the tokenizer level, it can continue (with some junk) but it is a serious error and the
&nbsp;     * caller probably should treat as an error and stop.
&nbsp;     * @param message description of error
&nbsp;     * @param args details to populate description
&nbsp;     */
&nbsp;    private void error(String message, Object... args) {
<b class="nc">&nbsp;        String msg = String.format(message, args);</b>
<b class="nc">&nbsp;        errorHandler.error(msg, reader.getLineNum(), reader.getColNum());</b>
<b class="nc">&nbsp;        throw new AttributeSyntaxError(msg);</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Structural error - unrecoverable - but reported as ERROR (FATAL can imply system fault) */
&nbsp;    private void fatal(String message, Object... args) {
<b class="fc">&nbsp;        String msg = String.format(message, args);</b>
<b class="fc">&nbsp;        long line = reader.getLineNum();</b>
<b class="pc">&nbsp;        if ( line == 1 )</b>
&nbsp;            // Lien is normally 1: pon&#39;t print.
<b class="fc">&nbsp;            line = -1;</b>
<b class="fc">&nbsp;        errorHandler.fatal(msg, line, reader.getColNum());</b>
&nbsp;        // We require that errors to cause the tokenizer to stop so in case the
&nbsp;        // provided error handler does not, we throw an exception.
<b class="nc">&nbsp;        throw new AttributeSyntaxError(message);</b>
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-11-26 08:49</div>
</div>
</body>
</html>
