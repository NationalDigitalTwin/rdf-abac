


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > HasherUtil</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">io.telicent.jena.abac.labels.hashing</a>
</div>

<h1>Coverage Summary for Class: HasherUtil (io.telicent.jena.abac.labels.hashing)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">HasherUtil</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (16/16)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (32/32)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package io.telicent.jena.abac.labels.hashing;
&nbsp;
&nbsp;import net.openhft.hashing.LongTupleHashFunction;
&nbsp;
&nbsp;import static com.google.common.hash.Hashing.*;
&nbsp;import static net.openhft.hashing.LongHashFunction.*;
&nbsp;import static net.openhft.hashing.LongTupleHashFunction.xx128;
&nbsp;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.Map;
&nbsp;import java.util.function.Supplier;
&nbsp;
&nbsp;/**
&nbsp; * Utility class for generate hashing functions.
&nbsp; * Note: there is always a trade-off between speed of execution
&nbsp; * and the risk of collision.
&nbsp; */
&nbsp;public class HasherUtil {
&nbsp;
&nbsp;    /** Private constructor as to be used as a static class **/
&nbsp;    private HasherUtil(){};
&nbsp;
&nbsp;    /**
&nbsp;     * Mapping of string config parameters to Hash Functions
&nbsp;     */
<b class="fc">&nbsp;    public static final Map&lt;String, Supplier&lt;Hasher&gt;&gt; hasherMap = new HashMap&lt;&gt;();</b>
&nbsp;    static {
<b class="fc">&nbsp;        hasherMap.put(&quot;city64&quot;, HasherUtil::createCity64Hasher);</b>
<b class="fc">&nbsp;        hasherMap.put(&quot;farm64&quot;, HasherUtil::createFarm64Hasher);</b>
<b class="fc">&nbsp;        hasherMap.put(&quot;farmna64&quot;, HasherUtil::createFarmNaHasher);</b>
<b class="fc">&nbsp;        hasherMap.put(&quot;farmuo64&quot;, HasherUtil::createFarmUoHasher);</b>
<b class="fc">&nbsp;        hasherMap.put(&quot;metro64&quot;, HasherUtil::createMetro64Hasher);</b>
<b class="fc">&nbsp;        hasherMap.put(&quot;murmur64&quot;, HasherUtil::createMurmur64Hasher);</b>
<b class="fc">&nbsp;        hasherMap.put(&quot;murmur128&quot;, HasherUtil::createMurmer128Hasher);</b>
<b class="fc">&nbsp;        hasherMap.put(&quot;sha256&quot;, HasherUtil::createSHA256Hasher);</b>
<b class="fc">&nbsp;        hasherMap.put(&quot;sha512&quot;, HasherUtil::createSHA512Hasher);</b>
<b class="fc">&nbsp;        hasherMap.put(&quot;sip24&quot;, HasherUtil::createSIP24Hasher);</b>
<b class="fc">&nbsp;        hasherMap.put(&quot;wy3&quot;, HasherUtil::createWY64Hasher);</b>
<b class="fc">&nbsp;        hasherMap.put(&quot;xx32&quot;, HasherUtil::createXX32Hasher);</b>
<b class="fc">&nbsp;        hasherMap.put(&quot;xx64&quot;, HasherUtil::createXX64Hasher);</b>
<b class="fc">&nbsp;        hasherMap.put(&quot;xx128&quot;, HasherUtil::createXX128Hasher);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Obtain the appropriate Hasher based on the provided string key.
&nbsp;     *
&nbsp;     * @param string The string key representing the hashing algorithm.
&nbsp;     * @return The corresponding Hasher. Defaults to 64 Bit XX.
&nbsp;     */
&nbsp;    public static Hasher obtainHasherFromConfig(String string) {
<b class="fc">&nbsp;        if (null == string || string.isEmpty()) {</b>
<b class="fc">&nbsp;            return createXX128Hasher();</b>
&nbsp;        }
<b class="fc">&nbsp;        return hasherMap.getOrDefault(string.toLowerCase(), HasherUtil::createXX128Hasher).get();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Create a 64-bit XX Hash function.
&nbsp;     * - Very fast, often used in scenarios requiring speed over collision resistance.
&nbsp;     * - Not cryptographically secure.
&nbsp;     * - Lower collision resistance compared to 128-bit variant. Still rare, with about
&nbsp;     * 2^32 hashes (~4 billion) before a collision is expected.
&nbsp;     *
&nbsp;     * @return A Hasher using the 64-bit XX Hash algorithm.
&nbsp;     */
&nbsp;    public static Hasher createXX64Hasher() {
<b class="fc">&nbsp;        return new BaseLongHasher(xx3());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Create a 32-bit XX Hash function.
&nbsp;     * - Extremely fast for small inputs. Faster than 64, 128 variants
&nbsp;     * - Not cryptographically secure.
&nbsp;     * - Limited collision resistance due to the smaller 32-bit output space.
&nbsp;     * Around 2^16 (65,000) hashes before expecting a collision.
&nbsp;     *
&nbsp;     * @return A Hasher using the 32-bit XX Hash algorithm.
&nbsp;     */
&nbsp;    public static Hasher createXX32Hasher() {
<b class="fc">&nbsp;        return new BaseLongHasher(xx());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Create a 64-bit Farm Hash function.
&nbsp;     * - Highly optimized for speed on 64-bit architectures.
&nbsp;     * - Not cryptographically secure.
&nbsp;     * - Slightly slower than equivalent XX Hash in some scenarios.
&nbsp;     * - Collision rate probability grows significantly at 2^32 hashes.
&nbsp;     *
&nbsp;     * @return A Hasher using the 64-bit Farm Hash algorithm.
&nbsp;     */
&nbsp;    public static Hasher createFarm64Hasher() {
<b class="fc">&nbsp;        return new BaseHasher(farmHashFingerprint64());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Create a Sip Hash function.
&nbsp;     * - Cryptographically secure, designed for resistance against hash-flooding attacks.
&nbsp;     * - Slower than non-cryptographic hash functions like XX or Murmur.
&nbsp;     * - Collision rate is low, significantly increasing after 2^64 hashes.
&nbsp;     *
&nbsp;     * @return A Hasher using the Sip 24 algorithm.
&nbsp;     */
&nbsp;    public static Hasher createSIP24Hasher() {
<b class="fc">&nbsp;        return new BaseHasher(sipHash24());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Create a SHA-256 Hash function.
&nbsp;     * - Cryptographically secure, widely used in security applications.
&nbsp;     * - Extremely low chance of collisions (256-bit hash). Almost impossible,
&nbsp;     * with 2^128 hashes (340 undecillion) before collisions become probable.
&nbsp;     * - Significantly slower than non-cryptographic hash functions.
&nbsp;     *
&nbsp;     * @return A Hasher using the SHA-256 algorithm.
&nbsp;     */
&nbsp;    public static Hasher createSHA256Hasher() {
<b class="fc">&nbsp;        return new BaseHasher(sha256());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Create a SHA-512 Hash Function
&nbsp;     * - Cryptographically secure with an even larger 512-bit hash size.
&nbsp;     * - Almost zero chance of collisions in practical applications. With
&nbsp;     * 2^512 hashes (115 quattuorvigintillion) before the possibility of
&nbsp;     * collision becomes significant.
&nbsp;     * - Even slower than SHA-256, especially on 32-bit architectures.
&nbsp;     *
&nbsp;     * @return A Hasher using the SHA-512 algorithm.
&nbsp;     */
&nbsp;    public static Hasher createSHA512Hasher() {
<b class="fc">&nbsp;        return new BaseHasher(sha512());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Create a 64-bit City Hash function.
&nbsp;     * - Optimized for small, short strings.
&nbsp;     * - Performs well in low-latency environments.
&nbsp;     * - Not cryptographically secure.
&nbsp;     * - Slightly slower than XX equivalent.
&nbsp;     * - Collision probability similar to other 64 bit functions.
&nbsp;     *
&nbsp;     * @return A Hasher using the City Hash 64-bit algorithm.
&nbsp;     */
&nbsp;    public static Hasher createCity64Hasher() {
<b class="fc">&nbsp;        return new BaseLongHasher(city_1_1());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Create a 64-bt Farm Hash NA function.
&nbsp;     * - Fast on modern architectures and optimized for various input sizes.
&nbsp;     * - Not cryptographically secure.
&nbsp;     * - Collision probability similar to other 64 bit functions.
&nbsp;     *
&nbsp;     * @return A Hasher using the Farm Hash NA 64-bit algorithm.
&nbsp;     */
&nbsp;    public static Hasher createFarmNaHasher() {
<b class="fc">&nbsp;        return new BaseLongHasher(farmNa());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Create a 64-bit Farm Hash UO function.
&nbsp;     * - Similar to FarmHash NA, optimized for various architectures.
&nbsp;     * - Not cryptographically secure.
&nbsp;     * - Collision probability similar to other 64 bit functions.
&nbsp;     *
&nbsp;     * @return A Hasher using the FarmHash UO algorithm.
&nbsp;     */
&nbsp;    public static Hasher createFarmUoHasher() {
<b class="fc">&nbsp;        return new BaseLongHasher(farmUo());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Create a 64-bit Metro Hash function.
&nbsp;     * - High-speed hash function for use in hash tables and checksums.
&nbsp;     * - Not cryptographically secure.
&nbsp;     * - Collision probability similar to other 64 bit functions.
&nbsp;     *
&nbsp;     * @return A Hasher using the Metro Hash 64-bit algorithm.
&nbsp;     */
&nbsp;    public static Hasher createMetro64Hasher() {
<b class="fc">&nbsp;        return new BaseLongHasher(metro());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Create a 64-bit Murmur Hash Function.
&nbsp;     * - Very fast on both 32-bit and 64-bit architectures.
&nbsp;     * - Good distribution for general-purpose use cases.
&nbsp;     * - Not cryptographically secure.
&nbsp;     * - Collision probability similar to other 64 bit functions.
&nbsp;     *
&nbsp;     * @return A Hasher using the Murmur Hash 64-bit algorithm.
&nbsp;     */
&nbsp;    public static Hasher createMurmur64Hasher() {
<b class="fc">&nbsp;        return new BaseLongHasher(murmur_3());</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Create a 64-bit WY Hash function.
&nbsp;     * - Extremely fast, suitable for performance-sensitive environments.
&nbsp;     * - Not cryptographically secure.
&nbsp;     * - Collision probability similar to other 64 bit functions.
&nbsp;     *
&nbsp;     * @return A Hasher using the WY3 algorithm.
&nbsp;     */
&nbsp;    public static Hasher createWY64Hasher() {
<b class="fc">&nbsp;        return new BaseLongHasher(wy_3());</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Create a 128-bit XX Hash function.
&nbsp;     * - Extremely fast, often the fastest non-cryptographic hash function.
&nbsp;     * - Not cryptographically secure.
&nbsp;     * - 128-bit size offers good collision resistance. The number of hashes
&nbsp;     * required before expecting a collision is in the region of ~2^64 (a quintillion) so very rare.
&nbsp;     * - Slower than 64 and 32 bit variants.
&nbsp;     *
&nbsp;     * @return A Hasher using the 128-bit XX Hash algorithm.
&nbsp;     */
&nbsp;    public static Hasher createXX128Hasher() {
<b class="fc">&nbsp;        return new BaseLongTupleHasher(xx128());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Create a 128-bit Murmur Hash Function.
&nbsp;     * - High-performance with better collision resistance than MurmurHash 64-bit.
&nbsp;     * - Not cryptographically secure.
&nbsp;     * @return A Hasher using the Murmur Hash 128-bit algorithm.
&nbsp;     */
&nbsp;    public static Hasher createMurmer128Hasher() {
<b class="fc">&nbsp;        return new BaseLongTupleHasher(LongTupleHashFunction.murmur_3());</b>
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-11-26 08:49</div>
</div>
</body>
</html>
