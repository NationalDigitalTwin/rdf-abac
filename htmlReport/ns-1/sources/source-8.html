


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > LabelsStoreMem</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">io.telicent.jena.abac.labels</a>
</div>

<h1>Coverage Summary for Class: LabelsStoreMem (io.telicent.jena.abac.labels)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">LabelsStoreMem</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/22)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/18)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/69)
  </span>
</td>
</tr>
  <tr>
    <td class="name">LabelsStoreMem$TransactionalHook</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/25)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/22)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/76)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; *  Copyright (c) Telicent Ltd.
&nbsp; *
&nbsp; *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; *  you may not use this file except in compliance with the License.
&nbsp; *  You may obtain a copy of the License at
&nbsp; *
&nbsp; *      http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; *  Unless required by applicable law or agreed to in writing, software
&nbsp; *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; *  See the License for the specific language governing permissions and
&nbsp; *  limitations under the License.
&nbsp; */
&nbsp;
&nbsp;package io.telicent.jena.abac.labels;
&nbsp;
&nbsp;import static org.apache.jena.sparql.util.NodeUtils.nullToAny;
&nbsp;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.concurrent.ConcurrentHashMap;
&nbsp;import java.util.function.BiConsumer;
&nbsp;
&nbsp;import io.telicent.jena.abac.SysABAC;
&nbsp;import org.apache.jena.graph.Graph;
&nbsp;import org.apache.jena.graph.Node;
&nbsp;import org.apache.jena.graph.Triple;
&nbsp;import org.apache.jena.query.ReadWrite;
&nbsp;import org.apache.jena.riot.out.NodeFmtLib;
&nbsp;import org.apache.jena.sparql.core.Transactional;
&nbsp;import org.apache.jena.sparql.core.TransactionalNull;
&nbsp;import org.apache.jena.system.Txn;
&nbsp;import org.slf4j.Logger;
&nbsp;import org.slf4j.LoggerFactory;
&nbsp;
&nbsp;/**
&nbsp; * In-memory labels store, concrete triple to label map, no patterns matched.
&nbsp; */
&nbsp;public class LabelsStoreMem implements LabelsStore {
&nbsp;
<b class="nc">&nbsp;    private static final Logger LOG = LoggerFactory.getLogger(Labels.class);</b>
&nbsp;
&nbsp;    // Triple indexing.
&nbsp;    // This is not protected by the transactional.
&nbsp;    // It is thread-safe but may be read inconsistently.
<b class="nc">&nbsp;    private final Map&lt;Triple, List&lt;String&gt;&gt; tripleLabels = new ConcurrentHashMap&lt;&gt;();</b>
&nbsp;
&nbsp;    // Update accumulator used to collect updates which are then flushed to tripleLabels on commit.
&nbsp;    // This allows for a data load operation to abort. The accumulator is flushed
&nbsp;    // after data has been loaded into the triple store, so it is syntactically valid,
&nbsp;    // and before the data is committed and becomes visible.
&nbsp;    //
&nbsp;    // We prefer better availability (writes do not block readers) over consistency.
&nbsp;    // Consistency is minimised for slow updates by use of the accumulator.
&nbsp;
<b class="nc">&nbsp;    private final Map&lt;Triple, List&lt;String&gt;&gt; accTripleLabels = new ConcurrentHashMap&lt;&gt;();</b>
&nbsp;
&nbsp;    // Future: Consider binding LabelsStore to the DatasetGraphABAC transactional so
&nbsp;    // that operations on the labels side are also protected.
&nbsp;    // While all operation go through a DatasetGraphABAC, the dataset is MR+SW (reads can overlap writes).
&nbsp;    // We choose availability (see asGraph()) over consistency.
&nbsp;
&nbsp;    // Used to give consistent update flushing accumulated triples.
&nbsp;    private final Transactional transactional;
&nbsp;
&nbsp;    /**
&nbsp;     * TransactionalNull tracks the transaction state so these
&nbsp;     * calls know if they are part of a write transaction.
&nbsp;     */
<b class="nc">&nbsp;    private class TransactionalHook extends TransactionalNull {</b>
&nbsp;        @Override
&nbsp;        public void commit() {
&nbsp;            // transactionMode() reflects the current thread transaction state.
<b class="nc">&nbsp;            if ( super.transactionMode() == ReadWrite.WRITE ) {</b>
&nbsp;                // Flush the triple label accumulator to the main store.
<b class="nc">&nbsp;                flushAccumulator();</b>
&nbsp;            }
<b class="nc">&nbsp;            super.commit();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void abort() {
<b class="nc">&nbsp;            if ( super.transactionMode() == ReadWrite.WRITE )</b>
<b class="nc">&nbsp;                clearAccumulator();</b>
<b class="nc">&nbsp;            super.abort();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /** A fresh, empty in-memory {@link LabelsStore} */
&nbsp;    /*package*/ public static LabelsStore create() {
<b class="nc">&nbsp;        LabelsStoreMem store = new LabelsStoreMem();</b>
<b class="nc">&nbsp;        return store;</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    private LabelsStoreMem() {</b>
&nbsp;        // Called from DatasetGraphABAC in its transaction lifecycle.
<b class="nc">&nbsp;        this.transactional = new TransactionalHook();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
<b class="nc">&nbsp;    public Transactional getTransactional() { return transactional; }</b>
&nbsp;
&nbsp;    // ---- Read operations ----
&nbsp;
&nbsp;    @Override
&nbsp;    public List&lt;String&gt; labelsForTriples(Triple triple) {
<b class="nc">&nbsp;        if ( ! triple.isConcrete() ) {</b>
<b class="nc">&nbsp;            LOG.error(&quot;Asked for labels for a triple with wildcards: {}&quot;, NodeFmtLib.displayStr(triple));</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        try {
<b class="nc">&nbsp;            readOperation();</b>
<b class="nc">&nbsp;        } catch (AuthzTriplePatternException ex) {</b>
<b class="nc">&nbsp;            LOG.error(&quot;Failed to update index: {}&quot;, ex.getMessage());</b>
<b class="nc">&nbsp;            return List.of(SysABAC.denyLabel);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        List&lt;String&gt; x = tripleLabels.get(triple);</b>
&nbsp;        //FmtLog.info(ABAC.AzLOG, &quot;%s : %s\n&quot;, NodeFmtLib.str(triple), x);
<b class="nc">&nbsp;        return x==null ? List.of() : x;</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Signal a read operation. */
&nbsp;    private void readOperation() {
&nbsp;        // Needed when the store is standalone (e.g. tests!) and there is no transaction lifecycle in use.
<b class="nc">&nbsp;        if ( ! transactional.isInTransaction() )</b>
<b class="nc">&nbsp;            flushAccumulator();</b>
&nbsp;    }
&nbsp;    /** Signal a write operation. */
<b class="nc">&nbsp;    private void writeOperation() {}</b>
&nbsp;
&nbsp;    @Override
&nbsp;    public void forEach(BiConsumer&lt;Triple, List&lt;String&gt;&gt; action) {
<b class="nc">&nbsp;        readOperation();</b>
<b class="nc">&nbsp;        tripleLabels.forEach(action);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Graph asGraph() {
<b class="nc">&nbsp;        readOperation();</b>
<b class="nc">&nbsp;        Graph gResult = L.newLabelGraph();</b>
&nbsp;        // Thread-safe, but not guaranteed to be consistent.
<b class="nc">&nbsp;        L.labelsToGraph(this, gResult);</b>
<b class="nc">&nbsp;        return gResult;</b>
&nbsp;// No point. The calculateRead does not guarantee the graph is a consistent snapshot
&nbsp;// because the transactional is only used to flush the accumulator.
&nbsp;//        return Txn.calculateRead(transactional, ()-&gt;{
&nbsp;//            Graph gResult = L.newLabelGraph();
&nbsp;//            L.labelsToGraph(this, gResult);
&nbsp;//            return gResult;
&nbsp;//        });
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * The properties of the default label store include the size of the labels map.
&nbsp;     *
&nbsp;     * @return the properties of the label store
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Map&lt;String, String&gt; getProperties() {
<b class="nc">&nbsp;        final var properties = new HashMap&lt;String, String&gt;();</b>
<b class="nc">&nbsp;        properties.put(&quot;size&quot;, &quot;&quot; + tripleLabels.size());</b>
<b class="nc">&nbsp;        return properties;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean isEmpty() {
<b class="nc">&nbsp;        readOperation();</b>
<b class="nc">&nbsp;        return tripleLabels.isEmpty();</b>
&nbsp;    }
&nbsp;
&nbsp;    private void flushAccumulator() {
<b class="nc">&nbsp;        if ( ! accTripleLabels.isEmpty() ) {</b>
&nbsp;            // Ensure only one thread is emptying the accumulator.
&nbsp;            // While ConcurrentHashMaps are safe, the putAll and clear need to be one step.
<b class="nc">&nbsp;            synchronized(this) {</b>
&nbsp;                // This is the only write to the main triples-&gt;labels map.
&nbsp;                // accTripleLabels is not protected but either:
&nbsp;                //   Transaction in use and only the write transaction will update accTripleLabels.
&nbsp;                //   Freestanding usage in tests when all work is single threaded.
<b class="nc">&nbsp;                tripleLabels.putAll(accTripleLabels);</b>
<b class="nc">&nbsp;                clearAccumulator();</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void clearAccumulator() {
<b class="nc">&nbsp;        accTripleLabels.clear();</b>
&nbsp;    }
&nbsp;
&nbsp;    // ---- Update operations  ----
&nbsp;
&nbsp;    @Override
&nbsp;    public void addGraph(Graph labels) {
<b class="nc">&nbsp;        writeOperation();</b>
<b class="nc">&nbsp;        if ( transactional.isInTransaction() ) {</b>
<b class="nc">&nbsp;            add$(labels);</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        Txn.executeWrite(transactional, ()-&gt;add$(labels) );</b>
&nbsp;    }
&nbsp;
&nbsp;    private void add$(Graph labelsGraph) {
&nbsp;        // Check the small incoming graph.
<b class="nc">&nbsp;        L.checkShape(labelsGraph);</b>
&nbsp;        // Concrete triples only
&nbsp;//        L.loadStoreFromGraph(this, labels);
&nbsp;
&nbsp;        // Allow patterns.
<b class="nc">&nbsp;        BiConsumer&lt;TriplePattern, List&lt;String&gt;&gt; destination = this::addToIndex;</b>
<b class="nc">&nbsp;        L.graphToLabels(labelsGraph, destination);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void add(Triple triple, List&lt;String&gt; labels) {
<b class="nc">&nbsp;        writeOperation();</b>
<b class="nc">&nbsp;        add$(triple, labels);</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Add a triple pattern but do not rebuild index. */
&nbsp;    @Override
&nbsp;    public void add(Node subject, Node property, Node object, List&lt;String&gt; labels) {
<b class="nc">&nbsp;        writeOperation();</b>
<b class="nc">&nbsp;        Node s = nullToAny(subject);</b>
<b class="nc">&nbsp;        Node p = nullToAny(property);</b>
<b class="nc">&nbsp;        Node o = nullToAny(object);</b>
<b class="nc">&nbsp;        Triple triple = Triple.create(s, p, o);</b>
<b class="nc">&nbsp;        add(triple, labels);</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Add a triple pattern but do not rebuild index. */
&nbsp;    private void add$(Triple triple, List&lt;String&gt; labels) {
<b class="nc">&nbsp;        if ( triple.isConcrete() ) {</b>
<b class="nc">&nbsp;            L.validateLabels(labels);</b>
<b class="nc">&nbsp;            accTripleLabels.put(triple, labels);</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
&nbsp;        // Patterns. Dispatch (
<b class="nc">&nbsp;        if ( !L.isPatternTriple(triple) )</b>
<b class="nc">&nbsp;            throw new AuthzTriplePatternException(&quot;Bad triple pattern: &quot;+NodeFmtLib.str(triple));</b>
<b class="nc">&nbsp;        TriplePattern triplePattern = TriplePattern.create(triple);</b>
<b class="nc">&nbsp;        addToIndex(triplePattern, labels);</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;
&nbsp;    // ---- Patterns ----
&nbsp;    // Only available by loading from a graph.
&nbsp;    // This machinery is placeholder - patterns are not current used but
&nbsp;
&nbsp;    /** Add to the index. */
&nbsp;    private void addToIndex(TriplePattern pattern, List&lt;String&gt; labels) {
<b class="nc">&nbsp;        L.validateLabels(labels);</b>
<b class="nc">&nbsp;        if ( pattern.isConcrete() ) {</b>
<b class="nc">&nbsp;            addConcreteToIndex(pattern, labels);</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        throw new UnsupportedOperationException(&quot;Pattern: &quot;+pattern);</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Index a single specific triple. */
&nbsp;    private void addConcreteToIndex(TriplePattern pattern, List&lt;String&gt; labels) {
<b class="nc">&nbsp;        if ( labels.isEmpty() )</b>
&nbsp;            return;
<b class="nc">&nbsp;        Triple triple = pattern.asTriple();</b>
<b class="nc">&nbsp;        this.add(triple, labels);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void remove(Triple triple) {
<b class="nc">&nbsp;        this.tripleLabels.remove(triple);</b>
<b class="nc">&nbsp;        this.accTripleLabels.remove(triple);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;        public String toString() {
<b class="nc">&nbsp;            return String.format(&quot;%s[%d]&quot;, this.getClass().getSimpleName(), tripleLabels.size());</b>
&nbsp;            // Small scale only!
&nbsp;    //        Graph g = getGraph();
&nbsp;    //        return RDFWriter.source(g).lang(Lang.TTL).asString();
&nbsp;        }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-11-26 08:01</div>
</div>
</body>
</html>
