


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > StoreFmtByNodeId</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">io.telicent.jena.abac.labels</a>
</div>

<h1>Coverage Summary for Class: StoreFmtByNodeId (io.telicent.jena.abac.labels)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">StoreFmtByNodeId</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    44.4%
  </span>
  <span class="absValue">
    (4/9)
  </span>
</td>
</tr>
  <tr>
    <td class="name">StoreFmtByNodeId$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">StoreFmtByNodeId$Encoder</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (16/16)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">StoreFmtByNodeId$Parser</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    94.1%
  </span>
  <span class="absValue">
    (16/17)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    92.3%
  </span>
  <span class="absValue">
    (12/13)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (8/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    86%
  </span>
  <span class="absValue">
    (37/43)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; *  Copyright (c) Telicent Ltd.
&nbsp; *
&nbsp; *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; *  you may not use this file except in compliance with the License.
&nbsp; *  You may obtain a copy of the License at
&nbsp; *
&nbsp; *      http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; *  Unless required by applicable law or agreed to in writing, software
&nbsp; *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; *  See the License for the specific language governing permissions and
&nbsp; *  limitations under the License.
&nbsp; */
&nbsp;package io.telicent.jena.abac.labels;
&nbsp;
&nbsp;import org.apache.jena.graph.Node;
&nbsp;import org.apache.jena.tdb2.store.NodeIdFactory;
&nbsp;import org.apache.jena.tdb2.store.nodetable.NodeTable;
&nbsp;
&nbsp;import java.nio.ByteBuffer;
&nbsp;import java.nio.charset.CharsetDecoder;
&nbsp;import java.nio.charset.StandardCharsets;
&nbsp;import java.util.Collection;
&nbsp;import java.util.List;
&nbsp;
&nbsp;/**
&nbsp; *
&nbsp; *  An id-based implementation of a storage format for {@code RocksDB}-based label stores.
&nbsp; *  &lt;p&gt;
&nbsp; *  Because it is id-based, this format receives and uses a {@link NodeTable} which it uses
&nbsp; *  to convert from nodes to ids as a step in formatting nodes into a RocksDB database.
&nbsp; */
&nbsp;public class StoreFmtByNodeId implements StoreFmt {
&nbsp;    @Override
&nbsp;    public Encoder createEncoder() {
<b class="fc">&nbsp;        return new Encoder();</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Parser createParser() {
<b class="fc">&nbsp;        return new Parser();</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    public StoreFmtByNodeId(final NodeTable storeNodeTable) {</b>
<b class="fc">&nbsp;        this.nodeTable = storeNodeTable;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * To aid with testing - provide a name
&nbsp;     * @return a toString()
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String toString() {
<b class="nc">&nbsp;        String className = getClass().toString();</b>
<b class="nc">&nbsp;        int lastDotIndex = className.lastIndexOf(&#39;.&#39;);</b>
<b class="nc">&nbsp;        if (lastDotIndex &gt;= 0) {</b>
<b class="nc">&nbsp;            className = className.substring(lastDotIndex + 1);</b>
&nbsp;        }
<b class="nc">&nbsp;        return className;</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    private final NodeTable nodeTable;
&nbsp;
&nbsp;    /**
&nbsp;     * Encoder for id-based encoding of a label store
&nbsp;     */
<b class="fc">&nbsp;    class Encoder implements StoreFmt.Encoder {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * byte 0 : 7 ................ 4  3 ............................. 0
&nbsp;         *          ordinal of node type  ordinal of IntSize of the node id
&nbsp;         * - that is all, if the node being encoded is a Node.Any
&nbsp;         * - otherwise,
&nbsp;         * byte 1..n as many bytes of integer as are encoded in the IntSize
&nbsp;         * 1..1 for IntSize.OneByte,
&nbsp;         * 1..2 for IntSize.TwoBytes,
&nbsp;         * 1..4 for IntSize.FourBytes,
&nbsp;         * 1..8 for IntSize.EightBytes
&nbsp;         * so a URI node with a long node-id takes up 9 bytes.
&nbsp;         * &lt;p&gt;
&nbsp;         * The main intent is that graphs where the node-ids fit within 32 bits are encoded
&nbsp;         * somewhat more space-efficiently than they would otherwise be,
&nbsp;         * without actually restricting the ids to 32 bits.
&nbsp;         *
&nbsp;         * @param byteBuffer to write the node(&#39;s id) to
&nbsp;         * @param node to format
&nbsp;         * @return the original encoder
&nbsp;         */
&nbsp;        @Override
&nbsp;        public Encoder formatSingleNode(ByteBuffer byteBuffer, Node node) {
&nbsp;
<b class="fc">&nbsp;            var nodeType = NodeType.of(node);</b>
<b class="fc">&nbsp;            int topByte = nodeType.ordinal() &lt;&lt; 4;</b>
<b class="fc">&nbsp;            var pos = byteBuffer.position();</b>
<b class="fc">&nbsp;            byteBuffer.position(pos + 1);</b>
<b class="pc">&nbsp;            switch (nodeType) {</b>
&nbsp;                case Any:
&nbsp;                    break;
&nbsp;                case URI:
&nbsp;                case Literal:
&nbsp;                case Blank:
<b class="fc">&nbsp;                    var nodeId = nodeTable.getAllocateNodeId(node);</b>
<b class="fc">&nbsp;                    topByte = topByte | StoreFmt.formatLongVariable(byteBuffer, nodeId.getPtrLocation()).ordinal();</b>
&nbsp;            }
<b class="fc">&nbsp;            byteBuffer.put(pos, (byte) topByte);</b>
&nbsp;
<b class="fc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Format a list of strings
&nbsp;         * &lt;p&gt;
&nbsp;         * As the values encoded for the (key,value)-pairs, these are encoded the same for both id-based
&nbsp;         * and string-based {@code StoreFmt}
&nbsp;         * &lt;/p&gt;
&nbsp;         * @param byteBuffer into which to encode the list of strings
&nbsp;         * @param strings to encode
&nbsp;         * @return fluently return the encoder being used
&nbsp;         */
&nbsp;        @Override
&nbsp;        public Encoder formatStrings(final ByteBuffer byteBuffer, final List&lt;String&gt; strings) {
&nbsp;
<b class="fc">&nbsp;            StoreFmt.formatStrings(byteBuffer, strings);</b>
<b class="fc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Format a triple using an id-based encoder
&nbsp;         * &lt;p&gt;
&nbsp;         * id-based encoding is much simpler than string-based. Once each constituent node has been looked up in the
&nbsp;         * {@link NodeTable} we simple have to encode that node&#39;s id.
&nbsp;         * &lt;/p&gt;
&nbsp;         * @param byteBuffer into which to encode the triple
&nbsp;         * @param subject node of the triple
&nbsp;         * @param predicate node of the triple
&nbsp;         * @param object node of the triple
&nbsp;         * @return fluently return the encoder being used
&nbsp;         */
&nbsp;        @Override
&nbsp;        public Encoder formatTriple(ByteBuffer byteBuffer, Node subject, Node predicate, Node object) {
<b class="fc">&nbsp;            formatSingleNode(byteBuffer, subject);</b>
<b class="fc">&nbsp;            formatSingleNode(byteBuffer, predicate);</b>
<b class="fc">&nbsp;            formatSingleNode(byteBuffer, object);</b>
&nbsp;
<b class="fc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Parser for id-based encoding of a label store
&nbsp;     */
<b class="fc">&nbsp;    class Parser implements StoreFmt.Parser {</b>
&nbsp;
<b class="fc">&nbsp;        private final CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder();</b>
&nbsp;
&nbsp;        /**
&nbsp;         * Reverse the id-based encoding of a single node
&nbsp;         * &lt;p&gt;
&nbsp;         * based on the format beginning:
&nbsp;         * byte 0 : 7 ................ 4  3 ............................. 0
&nbsp;         *           ordinal of node type  ordinal of IntSize of the node id
&nbsp;         *
&nbsp;         * @param byteBuffer containing the encoded node id
&nbsp;         * @return a node created by looking up the decoded id in the {@link NodeTable}
&nbsp;         */
&nbsp;        @Override
&nbsp;        public Node parseSingleNode(final ByteBuffer byteBuffer) {
&nbsp;
<b class="fc">&nbsp;            var topByte = byteBuffer.get();</b>
<b class="fc">&nbsp;            var nodeTypeOrdinal = (topByte &gt;&gt; 4) &amp; 0xf;</b>
<b class="fc">&nbsp;            var nodeType = NodeType.values()[nodeTypeOrdinal];</b>
<b class="pc">&nbsp;            switch (nodeType) {</b>
&nbsp;                case Any:
<b class="fc">&nbsp;                    return Node.ANY;</b>
&nbsp;                case Blank:
&nbsp;                case Literal:
&nbsp;                case URI:
<b class="fc">&nbsp;                    var intBytes = IntBytes.values()[topByte &amp; 0xf];</b>
<b class="fc">&nbsp;                    var nodeId = NodeIdFactory.createPtr(StoreFmt.parseLongVariable(byteBuffer, intBytes));</b>
<b class="fc">&nbsp;                    return nodeTable.getNodeForNodeId(nodeId);</b>
&nbsp;                default:
<b class="nc">&nbsp;                    throw new UnsupportedOperationException(&quot;Unexpected NodeType case: &quot; + nodeType);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Parse a triple consisting of 3 consecutive encoded node-ids
&nbsp;         *
&nbsp;         * @param byteBuffer containing the encoded node ids
&nbsp;         * @param spo a list to receive the resulting recreated nodes
&nbsp;         * @return fluently return the parser being used
&nbsp;         */
&nbsp;        @Override
&nbsp;        public Parser parseTriple(final ByteBuffer byteBuffer, final List&lt;Node&gt; spo) {
<b class="fc">&nbsp;            spo.add(parseSingleNode(byteBuffer));</b>
<b class="fc">&nbsp;            spo.add(parseSingleNode(byteBuffer));</b>
<b class="fc">&nbsp;            spo.add(parseSingleNode(byteBuffer));</b>
<b class="fc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Parse value (label) strings, using the common value string format shared between id-based and string-based
&nbsp;         * store formats.
&nbsp;         *
&nbsp;         * @param valueBuffer the buffer holding the encoded strings
&nbsp;         * @param labels a list to receive the resulting strings
&nbsp;         * @return fluently return the parser being used
&nbsp;         */
&nbsp;        @Override
&nbsp;        public Parser parseStrings(final ByteBuffer valueBuffer, final Collection&lt;String&gt; labels) {
<b class="fc">&nbsp;            StoreFmt.parseStrings(valueBuffer, decoder, labels);</b>
<b class="fc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-11-26 08:01</div>
</div>
</body>
</html>
